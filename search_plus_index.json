{"./":{"url":"./","title":"项目导航","keywords":"","body":"GitBookWeb 一直在努力,从未放弃 简介 开源项目 我的博客 联系方式 安装运行 # gitbook init # gitbook install # gitbook serve 关于GitBook的安装和使用 ➡️ https://www.jianshu.com/p/1f78d8018ea7 捐赠     如果感觉对您有帮助，请作者喝杯咖啡吧，请注明您的名字或者昵称，方便作者感谢o(￣︶￣)o 微信 支付宝 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:33 "},"blog/":{"url":"blog/","title":"我的博客","summary":"试剑江湖的技术博客","keywords":"","body":"我的博客 个人博客 GitHub 码云 简书 CSDN 博客园 微博 开源项目 主要涉及技术：Java后端开发、聚合支付、公众号开发、开源爱好者、Linux 博客将不定期更新，请小伙伴们随时关注哦！ 年少-有为的技术博客 https://iswxw.github.io/     欢迎来到试剑江湖的技术博客，这里将深入探讨相关技术，包括行业动态，架构设计，设计模式，框架使用等。 博客集成了个人简历、不蒜子访问量统计、404页面、百度提交收录链接、GitBook文档、评论系统Gitment、helper-live2d动态模型插件、背景音乐 （网易云音乐）、文章置顶功能 不浮躁，不偏激，不守旧，爱编程，爱后端，爱新技术，爱运动，爱旅行，执行力和学习能力都棒棒哒！ 归档文章 Java Linux ELK日志分析 MySQL Hexo 日记本 捐赠     如果感觉对您有帮助，请作者喝杯咖啡吧，请注明您的名字或者昵称，方便作者感谢o(￣︶￣)o 微信 支付宝 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-27 23:59:21 "},"opensource/":{"url":"opensource/","title":"开源项目","summary":"试剑江湖的开源项目","keywords":"","body":"开源项目 基于微服务架构且前后端分离的购物商城 基于springboot和springcloud系列的应用实践 Go 深入浅出 Java 技术书籍大全 技术学习笔记 一个会动的简历 捐赠     如果感觉对您有帮助，请作者喝杯咖啡吧，请注明您的名字或者昵称，方便作者感谢o(￣︶￣)o 微信 支付宝 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-28 21:30:39 "},"opensource/bs-cloud.html":{"url":"opensource/bs-cloud.html","title":"基于微服务架构且前后端分离的购物商城","summary":"基于微服务架构且前后端分离的购物商城","keywords":"","body":"购物商城 前言 bs-cloud，一个基于微服务架构的前后端分离的购物商城 项目介绍 购物商城（bs-cloud）一个基于微服务架构的前后端分离的购物商城。Web 端使用 Vue + ElementUi ，后端使用 SpringCloud + SpringBoot + Mybatis-plus进行开发， JWT 技术及 RSA 非对称加密实现真正无状态的单点登录，图片等文件上传至FastDFS 分布式文件存储服务器。 演示 github：https://github.com/iswxw/bs-cloud 视频演示地址：https://www.bilibili.com/video/BV1aa411F7ic 企鹅技术交流群：1102814874 项目特点 友好的代码结构及注释，便于阅读及二次开发 实现前后端分离，通过 Json 进行数据交互，前端再也不用关注后端技术 页面交互使用 Vue2.x，极大的提高了开发效率。 引入Swagger 多服务文档支持，方便编写 API 接口文档。 引入RabbitMQ 消息队列，用于同步ES索引库和后台管理新上架商品后的信息 引入ElasticSearch 实现商品过滤和搜索 基于 JWT 技术及 RSA 非对称加密实现真正无状态的单点登录 FastDFS 进行处理大量的分布式文件存储 基于 Nginx 实现初步的请求负载均衡和请求限流 项目目录 bs-cloud 是一款基于当下热门技术开发的购物商城。 cloud-doc-front 是前端文档部分 bs-webpc 是基于Vue实现的前台门户网站 wxw-manage-web 是基于Vue实现的管理商城后台 mysql 数据库脚本 shell 服务部署脚本 cloud-gateway-server 服务网关 cloud-registry-server 注册中心 cloud-server-auth 鉴权中心 cloud-server-cart 购物车 cloud-server-fileload 文件服务模块 cloud-server-order 订单支付模块，接入了支付宝沙箱支付 cloud-server-search 搜素服务，ElasticSearch和Solr作为全文检索工具，结合MQ维护索引库数据同步 cloud-server-user 用户中心，提供用户信息维护和管理 cloud-web-server 基础数据服务，提供管理后台和Web端API服务接口 关注&交流 感兴趣的小伙伴可以搜索或扫描下方二维码关注公众号【Java半颗糖】，一起交流学习。 欢迎使用和Star支持，如使用过程中碰到问题，可以提出Issue，我会尽力完善。 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-28 20:52:00 "},"opensource/wxw-boot.html":{"url":"opensource/wxw-boot.html","title":"基于springboot和springcloud系列的应用实践","summary":"基于springboot和springcloud系列的应用实践","keywords":"","body":"以Java语言为主的各种项目实践，涵盖各个业务、各个功能 github地址：https://github.com/iswxw/wxw-boot https://github.com/iswxw/springcloud2020 前言 现在市面上关于Java的教程和技术文章很多，其中有许多文章一上来就讲底层原理，这无疑给一些新手在理解上增加了难度，理解底层原理的前提是你的基本能力已经过关了。什么是基本能力呢？就是你能够使用这个技术去解决问题。 举一个较为极端的例子：现在很多关于MySQL文章都在讲解其底层原理，比如索引采用的B+树结构、事务是怎样实现的、千万级乃至上亿数据量怎么处理，等等，看完之后也了解相关知识了，但根据业务需求写一个复杂的SQL语句的时候就蒙圈了。 当我们去了解一个新框架、新组件、新技术时，第一步是了解其使用方法，在使用的过程中慢慢去了解其背后更深层次的原理，如果连一个技术的最佳实践都一无所知，又谈何深入理解呢？如果只知道理论却不去动手操作，那么很快就会忘记理论知识，我见过太多人在学习新技术时被那些“不接地气”的讲解给劝退了。 “知其所以然”的前提是“知其然”，为了弥补市面上“知其然”的空缺，我创建了【项目实践】这个系列。不谈那些“高大上”的东西，直接手把手教你实践，并且附上源码。让你在实践中掌握新的知识点，直观感受一项技术在实际项目中是如何运用的！然后再徐徐为你讲解技术背后的原理，让你真正做到“知其然”的同时轻松地“知其所以然”。 所有项目克隆下来即可运行，有部分项目质量甚至可以单独开一个仓库！点击star，我会不断更新更多项目实践的！ 以项目驱动学习，以实践检验真知 项目实践系列 2.1 springboot系列 【项目实战】spring-dubbo 【项目实战】spring-elasticsearch 【项目实战】spring-netty 【项目实战】spring-redis 【项目实战】spring-shiro 【项目实战】spring-xxl-job 【项目实战】spring-shardingsphere 【项目实战】spring-rocketmq 【项目实战】spring-zookeeper 【项目实战】spring-mongodb 【项目实战】spring-quarts 【项目实战】spring-memcached 【项目实战】spring-rabbitmq 【项目实战】spring-mybatis 【项目实战】spriing-kafka 【项目实战】spring-junit 【项目实战】spring-shell 【项目实战】spring-batch 【项目实战】spring-prometheus-grafana 【项目实战】spring-sentry 【项目实战】spring-configuration 2.2 springcloud系列 SpringCloud 生态 【项目实战 Spring Cloud Gataway】 【项目实战 Spring Cloud Hystrix】 【项目实战 Spring Cloud OpenFeign】 【项目实战 Spring Cloud sleuth】 分布式请求链路跟踪 【项目实战 Spring Cloud stream】 消息驱动 ，屏蔽底层 mq实现方式，统一消息编程模型 ，解决重复消费（使用消息分组解决）和持久化问题 【项目实战 Spring Cloud bus】 服务配置总线 【项目实战 Spring Cloud config】 服务集群配置中心 服务注册与发现 【项目实战 Spring Cloud Zookeeper】 【项目实战 Spring Cloud Consul 】 【项目实战 Spring Cloud Eureka】 【项目实战 Spring Cloud Nacos】 SpringCloud Alibaba系列 【项目实战 Spring Cloud nacos】 【项目实战 Spring Cloud alibaba-histrix】 【项目实战 Spring Cloud alibaba-seata】 【项目实战 Spring Cloud alibaba-sentinel】 欢迎使用和Star支持，如使用过程中碰到问题，可以提出Issue，我会尽力完善。 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-28 21:13:38 "},"opensource/wxw-go.html":{"url":"opensource/wxw-go.html","title":"Go 深入浅出","summary":"Go 深入浅出","keywords":"","body":" wxw-go 一个零基础入门的 Golang 的教程 在线阅读：https://golang.iswxw.com 文章目录 第一章：基础知识 1. 基础知识之流程控制 2. 基础知识之异常处理 3. 基础知识之函数 第二章：面向对象 1. 面向对象之结构体 2. 面向对象之接口 3. 面向对象之数组 4. 面向对象之切片Slice 5. 面向对象之集合Map 第三章：并发编程 1. 并发编程 概述 2. 并发编程之goroutine 第四章：数据操作 1. Go 操作MySQL 2. Go 操作 Redis 第五章：源码学习 1. package/sync 2. pkg/context 3. package/encoding/json 第六章：工程实践 1. 工程实践之测试 2. 工程实践之安全 对文章有什么疑问，对项目有什么建议，可以添加微信与我交流，同时欢迎在主页关注微信公众号。 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-28 21:25:15 "},"opensource/wxw-ebook.html":{"url":"opensource/wxw-ebook.html","title":"Java 技术书籍大全","summary":"Java 技术书籍大全","keywords":"","body":"推荐一个在线搜课程的神器，“课程搜”：https://www.kcsou.com/s_Java/ GitHub地址：https://github.com/iswxw/wxw-ebook 本文档目前已收录 277本 Java相关领域经典技术书籍，从初级开发者到资深架构师，涵盖 Java 从业者的各个阶段，并持续更新。 涵盖领域：Java入门书籍，Java基础及进阶书籍，框架与中间件，架构设计，设计模式，数学与算法，JVM周边语言，项目管理&领导力&流程，职业素养与个人成长，格局与视野，面试参考书等。 推荐书籍可以点击 -> 点击这里 书籍列表 -> 点击这里 目录： 入门书籍 基础书籍 多线程与并发 网络编程 数据结构 语言基础 进阶 性能优化 响应式编程 JVM虚拟机 代码&设计优化 设计模式 框架与中间件 数据库 缓存与NoSQL 消息队列 ORM框架 Spring家族 高并发 分布式 搜索引擎 大数据 架构 分布式架构 微服务架构 架构方法论 JVM周边语言 项目管理&领导力&流程 项目管理 团队管理 数学与算法 数学 算法 职业素养与个人成长 职业素养提升 个人软技能 大厂出品 阿里巴巴技术丛书 京东技术丛书 工具书 面试求职 格局与视野 Java之外 网络知识 安全知识 工具 运维&DevOps TOC generated by simple-php-github-toc ​ 入门书籍 《明解Java》 - 豆瓣评分 8.5 《Java从入门到精通（第4版 附光盘）》 - 豆瓣评分 6 《入门很简单丛书：Java Web开发入门很简单》 《程序员炼成记 从小白到工程师》 《Java从小白到大牛》 《JavaWeb项目开发实战入门（全彩版）》 《Java精彩编程200例（全彩版）》 《Java轻松学》 《大话Java：程序设计从入门到精通（含DVD光盘1张）》 《Java语言袖珍指南（第二版）》 基础书籍 《Java编程思想（第4版） [thinking in java]》 - 豆瓣评分 9.1 《Java核心技术 卷I：基础知识（原书第10版）》 - 豆瓣评分 8.2 《Java核心技术卷II：高级特性（原书第10版）》 - 豆瓣评分 7.7 多线程与并发 《华章专业开发者丛书·Java并发编程实战》 - 豆瓣评分 9.1 《Java多线程编程实战指南（设计模式篇）》 - 豆瓣评分 8.5 《图解Java多线程设计模式》 - 豆瓣评分 8.4 《实战Java高并发程序设计》 - 豆瓣评分 8.3 《Java高并发编程详解：多线程与架构设计》 - 豆瓣评分 7.6 《Java核心技术系列：Java多线程编程核心技术 [Java Multi-thread Programming]》 - 豆瓣评分 5.1 《Java并发编程：核心方法与框架》 《Java多线程与Socket：实战微服务框架》 《NIO与Socket编程技术指南》 《Java并发编程之美》 《实战Java高并发程序设计（第2版）》 网络编程 《Java网络编程（第四版） [Java network programming, forth edition]》 - 豆瓣评分 7.6 数据结构 《数据结构与算法分析：Java语言描述（原书第3版）》 - 豆瓣评分 8.3 《图解数据结构：使用Java》 《数据结构与算法Java语言描述》 语言基础 《Java 8实战》 - 豆瓣评分 9.2 《Java函数式编程》 - 豆瓣评分 8.9 《Java编程的逻辑》 - 豆瓣评分 8.9 《O'Reilly：Head First Java（中文版 第2版 涵盖Java5.0）》 - 豆瓣评分 8.7 《写给大忙人看的Java核心技术》 - 豆瓣评分 7.1 《精通lambda表达式：Java多核编程 [Mastering Lambdas: Java Programming in a Multicore]》 《Java 9模块化开发：核心原则与实践》 《Java JDK 9学习笔记》 《Java 9编程参考官方大全（第10版） [Java：Thte Complete Reference，Tenth Edition]》 《写给大忙人的Java SE 9核心技术》 进阶 《深入分析Java Web技术内幕（修订版）》 - 豆瓣评分 7.5 《Java RESTful Web Service实战（第2版）》 性能优化 《Java性能优化权威指南 [Java performance]》 - 豆瓣评分 8.4 《Java程序性能优化：让你的Java程序更快、更稳定》 - 豆瓣评分 8.1 《Java性能权威指南》 - 豆瓣评分 8.1 《51CTO学院系列丛书·实战Java虚拟机：JVM故障诊断与性能优化》 - 豆瓣评分 8 《Java性能调优指南》 - 豆瓣评分 7 《大话Java性能优化》 - 豆瓣评分 4.4 响应式编程 《响应式架构：消息模式Actor实现与Scala、Akka应用集成》 - 豆瓣评分 8.1 《RxJava响应式编程》 《RxJava 2.x 实战》 JVM虚拟机 《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》 - 豆瓣评分 8.9 《Java核心技术系列：Java虚拟机规范（Java SE 8版） [The Java Virtual Machine Specification Jave SE 8 Edition]》 - 豆瓣评分 8.3 《揭秘Java虚拟机：JVM设计原理与实现》 - 豆瓣评分 7.9 《HotSpot实战》 - 豆瓣评分 7.1 《Java从入门到动手写虚拟机1（套装共2册）》 代码&设计优化 《重构 改善既有代码的设计 Java语言版》 - 豆瓣评分 9.3 《代码大全（第2版）》 - 豆瓣评分 9.3 《Effective Java中文版（原书第3版）》 - 豆瓣评分 9 《代码整洁之道 程序员的职业素养》 - 豆瓣评分 8.8 《代码整洁之道 [Clean Code A Handbook of Agile Software Craftsmanship]》 - 豆瓣评分 8.6 《Spring实战（第4版）》 - 豆瓣评分 8.3 《代码不朽：编写可维护软件的10大要则（Java版）》 - 豆瓣评分 7 《Java代码与架构之完美优化 实战经典》 设计模式 《反应式设计模式》 - 豆瓣评分 9.3 《O'Reilly：Head First设计模式（中文版）》 - 豆瓣评分 9.2 《设计模式：可复用面向对象软件的基础》 - 豆瓣评分 9.1 《实现领域驱动设计 [Implementing Domain-Driven Design]》 - 豆瓣评分 8.7 《原创精品系列：设计模式之禅（第2版）》 - 豆瓣评分 8.7 《图解设计模式》 - 豆瓣评分 8.7 《大话设计模式》 - 豆瓣评分 8.3 《领域驱动设计 软件核心复杂性应对之道 修订版》 - 豆瓣评分 8 《Java测试驱动开发》 - 豆瓣评分 6.6 框架与中间件 数据库 《高性能MySQL（第3版）》 - 豆瓣评分 9.3 《MySQL技术内幕：InnoDB存储引擎（第2版）》 - 豆瓣评分 8.6 《大型网站系统与Java中间件实践》 - 豆瓣评分 7.9 《深入浅出MySQL 数据库开发 优化与管理维护 第2版》 - 豆瓣评分 7.5 《PostgreSQL修炼之道：从小工到专家》 - 豆瓣评分 7.3 《PostgreSQL技术内幕：查询优化深度探索》 缓存与NoSQL 《Redis 深度历险：核心原理与应用实践》 - 豆瓣评分 9 《Redis实战》 - 豆瓣评分 8 《Redis入门指南（第2版）》 - 豆瓣评分 7.6 《深入分布式缓存：从原理到实践》 - 豆瓣评分 7.1 《人人都是架构师：分布式系统架构落地与瓶颈突破》 - 豆瓣评分 6.7 《MongoDB应用设计模式》 - 豆瓣评分 6.1 《MongoDB实战 架构、开发与管理》 《NoSQL数据库入门与实践（基于MongoDB、Redis）》 消息队列 《RabbitMQ实战指南》 - 豆瓣评分 9.1 《Kafka权威指南》 - 豆瓣评分 8.9 《Kafka入门与实践》 - 豆瓣评分 7.7 《RocketMQ实战与原理解析》 - 豆瓣评分 7.2 《Kafka技术内幕 图文详解Kafka源码设计与实现》 - 豆瓣评分 6.9 《深入理解Kafka：核心设计与实践原理》 《分布式消息中间件实践》 ORM框架 《MyBatis从入门到精通》 - 豆瓣评分 7.7 Spring家族 《Spring微服务实战》 - 豆瓣评分 8.3 《Spring Cloud微服务实战》 - 豆瓣评分 7.9 《深入理解Spring Cloud与微服务构建》 - 豆瓣评分 7.7 《MyBatis技术内幕》 - 豆瓣评分 7.6 《Spring Boot实战》 - 豆瓣评分 7.2 《深入浅出Spring Boot 2.x》 - 豆瓣评分 7 《JavaEE开发的颠覆者：Spring Boot实战》 - 豆瓣评分 6.3 《Spring技术内幕：深入解析Spring架构与设计原理（第2版）》 - 豆瓣评分 5.9 《Spring Boot 2精髓：从构建小系统到架构分布式大系统》 - 豆瓣评分 4.8 《Spring 5开发大全》 《Spring Cloud微服务架构进阶》 《Spring源码深度解析 第2版》 《Spring MVC实战》 《Spring Boot编程思想（核心篇）（限量版亲笔签名书签 随机发售）》 《互联网轻量级SSM框架解密：Spring、Spring MVC、MyBatis源码深度剖析》 《Spring学习指南 第3版》 《精通Spring MVC 4》 高并发 《Netty实战》 - 豆瓣评分 7.8 《七周七并发模型》 - 豆瓣评分 7.8 《Netty权威指南（第2版）》 - 豆瓣评分 6.9 《Netty进阶之路：跟着案例学Netty》 分布式 《从Paxos到Zookeeper分布式一致性原理与实践》 - 豆瓣评分 7.8 《ZooKeeper：分布式过程协同技术详解》 - 豆瓣评分 7.2 搜索引擎 《从Lucene到Elasticsearch：全文检索实战》 大数据 《Hadoop权威指南：大数据的存储与分析(第4版)》 - 豆瓣评分 8.7 《Hadoop构建数据仓库实践》 - 豆瓣评分 8.3 《HBase权威指南 [HBase： The Definitive Guide]》 - 豆瓣评分 8.1 《图解Spark：核心技术与案例实战》 - 豆瓣评分 7.6 《Hive编程指南 [Programming Hive]》 - 豆瓣评分 7.4 《HBase应用架构》 架构 《Web性能权威指南》 - 豆瓣评分 8.8 《从零开始学架构：照着做，你也能成为架构师》 - 豆瓣评分 8.5 《Java应用架构设计：模块化模式与OSGi》 - 豆瓣评分 6.9 《大型网站技术架构演进与性能优化》 - 豆瓣评分 6.8 《高可用架构（第1卷）》 - 豆瓣评分 6.3 《Java架构师指南》 《大话代码架构（项目实战版）》 《小团队构建大网站：中小研发团队架构实践》 《未来架构 从服务化到云原生(限量签名 随机发放)》 分布式架构 《可伸缩架构：面向增长应用的高可用》 - 豆瓣评分 7.4 《分布式服务架构：原理、设计与实战》 - 豆瓣评分 7.2 《亿级流量网站架构核心技术 跟开涛学搭建高可用高并发系统》 - 豆瓣评分 6.6 《大型分布式网站架构设计与实践》 - 豆瓣评分 6.2 《可伸缩服务架构：框架与中间件》 - 豆瓣评分 5.9 《架构探险：从零开始写分布式服务框架》 - 豆瓣评分 5.9 《Cloud Native分布式架构原理与实践》 《分布式系统常用技术及案例分析（第2版）》 《云原生Java：Spring Boot、Spring Cloud与Cloud Foundry弹性系统设计》 微服务架构 《微服务设计》 - 豆瓣评分 8.2 《生产微服务》 - 豆瓣评分 8 《架构解密：从分布式到微服务》 - 豆瓣评分 5.8 《Java微服务》 - 豆瓣评分 5.3 《Spring Cloud 微服务架构开发实战（全新升级版）》 《微服务实践》 架构方法论 《架构整洁之道》 - 豆瓣评分 8.8 《企业应用架构模式 [Patterns of Enterprise Application Architecture]》 - 豆瓣评分 8.3 《企业IT架构转型之道 阿里巴巴中台战略思想与架构实战》 - 豆瓣评分 8.2 《聊聊“架构”》 - 豆瓣评分 7.6 《架构真经：互联网技术架构的设计原则（原书第2版）》 - 豆瓣评分 7.5 《软件架构设计：程序员向架构师转型必备（第2版）》 - 豆瓣评分 7.4 《恰如其分的软件架构 [Just Enough Software Architecture]》 - 豆瓣评分 7.3 《软件架构设计：大型网站技术架构与业务架构融合之道》 JVM周边语言 《Scala编程（第3版）》 - 豆瓣评分 9.4 《Groovy程序设计》 - 豆瓣评分 8.2 《快学Scala（第2版）》 - 豆瓣评分 8 《Kotlin极简教程》 《Scala集合技术手册》 项目管理&领导力&流程 《构建之法 现代软件工程（第三版）》 - 豆瓣评分 9 《精益思想（白金版）》 - 豆瓣评分 8.2 《给产品经理讲技术》 项目管理 《持续交付：发布可靠软件的系统方法》 - 豆瓣评分 8.7 《名家经典系列：人件（原书第3版） [Peopleware: Productive Projects and Teams]》 - 豆瓣评分 8.4 《硝烟中的Scrum和XP：我们如何实施Scrum》 - 豆瓣评分 8.4 《敏捷软件开发实践 估算与计划》 - 豆瓣评分 8.4 《人月神话（40周年中文纪念版） [The Mythical Man-Month：Essays on Software Engineering Anniversary Edition]》 - 豆瓣评分 8.3 《Scrum敏捷软件开发》 - 豆瓣评分 8 《用户故事与敏捷方法 [User Stories Applied:For Agile Software Development]》 - 豆瓣评分 8 《用户故事地图 [User Story Mapping]》 - 豆瓣评分 7.4 《知行合一 实现价值驱动的敏捷和精益开发》 《互联网项目管理实践精粹》 团队管理 《卓有成效的管理者（珍藏版） [The Effective Executive]》 - 豆瓣评分 8.8 《跃迁：从技术到管理的硅谷路径》 - 豆瓣评分 8.4 《告别失控 软件开发团队管理必读》 - 豆瓣评分 7.9 《赋能：打造应对不确定性的敏捷团队 [Team of Teams]》 - 豆瓣评分 7.6 《OKR工作法：谷歌、领英等顶级公司的高绩效秘籍 [Radical Focus]》 - 豆瓣评分 7.6 《CTO说》 - 豆瓣评分 7.3 《轻流程 IT团队的积分式绩效管理》 - 豆瓣评分 7 《技术领导力：程序员如何才能带团队》 - 豆瓣评分 5.4 《敏捷文化：如何打造优秀的高效能团队 [The Agile Culture: Leading through Trust and Owner]》 数学与算法 数学 《数学之美（第二版）》 - 豆瓣评分 8.9 《程序员的数学2 概率统计》 - 豆瓣评分 8.7 《程序员的数学3 线性代数》 - 豆瓣评分 8.6 《程序员的数学》 - 豆瓣评分 7.2 《程序员的数学思维修炼（趣味解读）》 - 豆瓣评分 5.4 《统计之美：人工智能时代的科学思维》 《统计思维：程序员数学之概率统计（第2版）》 算法 《算法导论（原书第3版）/计算机科学丛书 [Introduction to Algorithms, third edition]》 - 豆瓣评分 9.3 《算法图解》 - 豆瓣评分 8.4 《漫画算法：小灰的算法之旅（全彩）》 职业素养与个人成长 《我编程，我快乐：程序员职业规划之道》 - 豆瓣评分 7.9 《程序员的自我修养》 - 豆瓣评分 6.5 职业素养提升 《码农翻身：用故事给技术加点料》 - 豆瓣评分 9.1 《程序员修炼之道：从小工到专家》 - 豆瓣评分 8.8 《极客与团队：软件工程师的团队生存秘笈》 - 豆瓣评分 8.3 《程序员思维修炼(修订版)》 - 豆瓣评分 8.2 《高效能程序员的修炼》 - 豆瓣评分 8.2 《O'Reilly：卓有成效的程序员 [Productive programmer]》 - 豆瓣评分 8.1 《Java工程师修炼之道》 - 豆瓣评分 7.8 《程序员的成长课》 - 豆瓣评分 7.6 《高效程序员的45个习惯：敏捷开发修炼之道(修订版)》 - 豆瓣评分 7.6 《温伯格技术思想三部曲：颠覆完美软件 软件测试必须知道的几件事》 - 豆瓣评分 7.5 《温伯格技术思想三部曲：程序开发心理学（银年纪念版）》 - 豆瓣评分 7.4 《软件开发本质论：追求简约、体现价值、逐步构建》 - 豆瓣评分 7.3 《内外兼修：程序员的成长之路》 - 豆瓣评分 6.6 个人软技能 《把时间当作朋友（第3版 全彩）》 - 豆瓣评分 8.5 《暗时间》 - 豆瓣评分 8.4 《关键对话：如何高效能沟通（原书第2版） [Crucial Conversations: Tools for Talking When Stak]》 - 豆瓣评分 8.1 《温伯格技术思想三部曲：成为技术领导者 掌握全面解决问题的方法》 - 豆瓣评分 8 《软技能 代码之外的生存指南》 - 豆瓣评分 8 《程序员健康指南》 - 豆瓣评分 7.5 《如何把事情做到最好：改变全球9800万人的人生指导书 [Mastery]》 - 豆瓣评分 7.2 《程序员的英语》 - 豆瓣评分 5.9 《高效能人士的七个习惯（30周年纪念版）》 大厂出品 阿里巴巴技术丛书 《码出高效：Java开发手册》 - 豆瓣评分 8.8 《大数据之路 阿里巴巴大数据实践》 - 豆瓣评分 7.8 《技术之瞳 阿里巴巴技术笔试心得》 - 豆瓣评分 7.7 《淘宝技术这十年》 - 豆瓣评分 7.3 《尽在双11 阿里巴巴技术演进与超越》 - 豆瓣评分 7.1 《逆流而上：阿里巴巴技术成长之路》 - 豆瓣评分 6.9 京东技术丛书 《京东基础架构建设之路（全彩）》 - 豆瓣评分 6.2 《京东系统质量保障技术实战》 - 豆瓣评分 6.1 《京东技术解密》 - 豆瓣评分 6.1 工具书 《Linux命令行与shell脚本编程大全（第3版）》 - 豆瓣评分 9.1 《阿里巴巴Java开发手册》 - 豆瓣评分 8.3 《SQL即查即用 （全彩版）》 《Linux命令速查手册（第三版）》 面试求职 《剑指Offer：名企面试官精讲典型编程题（第2版）》 - 豆瓣评分 9.1 《编程之美：微软技术面试心得》 - 豆瓣评分 8.4 《Java程序员面试笔试宝典》 - 豆瓣评分 7.6 《Java程序员面试宝典（第4版）》 - 豆瓣评分 5 《编程之法：面试和算法心得》 《Java程序员面试算法宝典》 《Java程序员面试笔试真题库》 《Java程序员面试笔试真题与解析》 《Java核心技术及面试指南》 《解忧程序员：高薪编程、求职面试与成长转型宝典》 格局与视野 《全球科技通史》 - 豆瓣评分 9.4 《浪潮之巅 第三版 套装上下册》 - 豆瓣评分 9.3 《黑客与画家：硅谷创业之父Paul Graham文集 [Hackers and Painters Big Ldeas From the Computer Age]》 - 豆瓣评分 8.8 《软件随想录 卷1》 - 豆瓣评分 8.8 《软件随想录 卷2》 - 豆瓣评分 8.7 《编程人生：15位软件先驱访谈录》 - 豆瓣评分 8.5 《大教堂与集市（最新版） [The Cathedral & the Bazaar]》 - 豆瓣评分 8.4 《硅谷之谜：浪潮之巅 续集》 - 豆瓣评分 8.4 《原则 [Principles]》 - 豆瓣评分 8.4 《精益创业》 - 豆瓣评分 8.4 《态度：吴军博士新书》 - 豆瓣评分 8.1 《见识》 - 豆瓣评分 8.1 《极限创新 35岁之前改变世界的全球科技精英》 - 豆瓣评分 7.3 《大学的终结：泛在大学与高等教育革命》 - 豆瓣评分 7.2 《未来版图 全球聪明公司的科技创新趋势和商业化路径》 - 豆瓣评分 7.1 《你好哇，程序员——漫话程序员面试求职、升职加薪、创业与生活》 - 豆瓣评分 6.5 《图灵和ACM图灵奖（1966-2015 第五版） 纪念计算机诞生70周年》 《文明之光（全彩印刷套装1-4册）入选2014中国好书/第六届中华优秀出版物获奖图书》 《大师访谈录：成就非凡的软件人生》 Java之外 《计算机科学丛书：计算机程序的构造和解释（原书第2版）》 - 豆瓣评分 9.5 《计算机科学丛书：编译原理（第2版） [Compilers:Principle,Techniques and Tools]》 - 豆瓣评分 9.1 《一个APP的诞生——从零开始设计你的手机应用》 - 豆瓣评分 6.3 《大型网站性能优化实战：从前端、网络、CDN到后端、大促的全链路性能优化详解》 网络知识 《图解HTTP》 - 豆瓣评分 8.1 《图解TCP/IP 第5版》 - 豆瓣评分 7.8 安全知识 《白帽子讲Web安全（纪念版）》 - 豆瓣评分 7.4 《Web安全攻防：渗透测试实战指南》 工具 《Maven实战》 - 豆瓣评分 8.2 《大象：Thinking in UML（第2版）》 - 豆瓣评分 8.2 《Git学习指南》 - 豆瓣评分 6.7 《UML基础、案例与应用（第3版 修订版）》 运维&DevOps 《编码：隐匿在计算机软硬件背后的语言 [Code:The Hidden Language of Computer Hardware and Software]》 - 豆瓣评分 9.3 《DevOps实践指南》 - 豆瓣评分 9 《性能之巅：洞悉系统、企业与云计算》 - 豆瓣评分 8.7 《鸟哥的Linux私房菜 基础学习篇 第四版》 - 豆瓣评分 8.2 《DevOps开发运维训练营》 在线资源 singgel ——收集了各种计算机类的书籍资源 GitHub EbookFoundation 免费版提供编程书籍 汇集了大量编程电子书籍 在线网站 计算机书籍控 ——很不错的站点，可以看各种计算机类的书籍目录 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-28 21:29:24 "},"opensource/wxw-document.html":{"url":"opensource/wxw-document.html","title":"技术学习笔记","summary":"技术学习笔记","keywords":"","body":"个人学习笔记，主要来源于B站上视频的学习，同时会记录平时一些学习和项目中遇到的问题，如果对我的博客网站感兴趣的话，欢迎关注我的博客项目 笔记主要涵盖 Java，Spring，SpringCloud，计算机网络，操作系统，数据结构，Vue等 github地址：https://github.com/iswxw/wxw-document 背景 学习笔记，同时也会记录平时一些学习和项目中遇到的问题，如果对我的博客网站感兴趣的话，欢迎关注我的博客项目 如果笔记对您有帮助的话，欢迎star支持，谢谢~ 笔记主要涵盖：Java，JVM、JUC、Spring，SpringCloud，计算机网络，操作系统，数据结构，Vue等 本仓库有来源自己总结、网上收集、视频笔记，如果有侵权之处，可以联系我进行删除 因个人能力有限，笔记中可能还有很多错误的地方，还请大家能够多多指出交流，也欢迎各位小伙伴能够提交pull request请求进行完善 如果您要转载本仓库中的笔记到其它地方，欢迎添加笔记的仓库地址：wxw-document 推荐使用 https://iswxw.github.io/wxw-document/ 在线阅读，在线阅读内容本仓库同步一致。这种方式阅读的优势在于：左侧边栏有目录，阅读体验更好。 目录 大数据技术 1. ClickHouse 2. Flink 3. Doris 4. Flume 5. Hbase 云原生技术 1. Docker 2. Kubernates(K8S) 服务端技术 Curl GoLang Linux Python Shell 后端技术 1. Java Java基础 final 关键字解析 对泛型的理解 Java虚拟机 JVM类加载机制 2. 分布式中间件 缓存 Redis Memcached Mongodb 搜索引擎 ElasticStack 消息队列 kafka RabbitMQ RocketMQ Dubbo Zookeeper 3. 数据库 MySQL PostGreSQL SQL Server MyBatis 4. Spring系列 SpringBoot SpringBoot 与 Transactional 事务机制 SpringCloud SpringBoot源码学习 SpringCloudAlibaba nacos seata Sentinel 5. 开源框架 定时任务 Guava Oauth2.0 Redission 6. 数据结构与算法 数据结构与算法基础 剑指Offer LeetCode 架构技术 1. 编码实战 编码规范 Git Maven 2. 架构思维 架构理论 运维部署 Jenkinse构建和部署 如果笔记对您有帮助的话，欢迎使用和Star支持，如使用过程中碰到问题，可以提出Issue，我会尽力完善。 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-28 21:17:32 "},"opensource/resumes.html":{"url":"opensource/resumes.html","title":"一个会动的简历","summary":"一个会动的简历","keywords":"","body":"一个会动的简历 GitHub：https://github.com/iswxw/resumes 欢迎使用和Star支持，如使用过程中碰到问题，可以提出Issue，我会尽力完善 本项目源于：https://github.com/jirengu-inc/animating-resume。向作者表示深深的敬意。 This is my resume 预览 使用方法 git clone https://github.com/iswxw/resumes.git cd anires npm install npm run dev 部署方法 编辑 config/index.js，修改第 10 行的 assetsPublicPath，值为 项目名/public。如果你没有修改项目名 anires，则可跳过此步骤。 编译、上传 npm run build git add . git commit -m \"update\" git push 开启 GitHub Pages 功能，把生成的目标文件public/*放在你的web服务器上。 访问地址：https://your-github-username.github.io/anires/public Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-28 20:42:14 "},"java/boot/SpringBoot.html":{"url":"java/boot/SpringBoot.html","title":"SpringBoot2.0","keywords":"","body":"一、Spring Boot 入门 1、Spring Boot 简介 简化Spring应用开发的一个框架； 整个Spring技术栈的一个大整合； J2EE开发的一站式解决方案； 2、微服务 2014，martin fowler 微服务：架构风格（服务微化） 一个应用应该是一组小型服务；可以通过HTTP的方式进行互通； 单体应用：ALL IN ONE 微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元； 详细参照微服务文档 3、环境准备 http://www.gulixueyuan.com/ 谷粒学院 环境约束 –jdk1.8：Spring Boot 推荐jdk1.7及以上；java version \"1.8.0_112\" –maven3.x：maven 3.3以上版本；Apache Maven 3.3.9 –IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS –SpringBoot 1.5.9.RELEASE：1.5.9； 统一环境； 1、MAVEN设置； 给maven 的settings.xml配置文件的profiles标签添加 jdk-1.8 true 1.8 1.8 1.8 1.8 2、IDEA设置 整合maven进来； 4、Spring Boot HelloWorld 一个功能： 浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串； 1、创建一个maven工程；（jar） 2、导入spring boot相关的依赖 org.springframework.boot spring-boot-starter-parent 1.5.9.RELEASE org.springframework.boot spring-boot-starter-web 3、编写一个主程序；启动Spring Boot应用 /** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */ @SpringBootApplication public class HelloWorldMainApplication { public static void main(String[] args) { // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); } } 4、编写相关的Controller、Service @Controller public class HelloController { @ResponseBody @RequestMapping(\"/hello\") public String hello(){ return \"Hello World!\"; } } 5、运行主程序测试 6、简化部署 org.springframework.boot spring-boot-maven-plugin 将这个应用打成jar包，直接使用java -jar的命令进行执行； 5、Hello World探究 1、POM文件 1、父项目 org.springframework.boot spring-boot-starter-parent 1.5.9.RELEASE 他的父项目是 org.springframework.boot spring-boot-dependencies 1.5.9.RELEASE ../../spring-boot-dependencies 他来真正管理Spring Boot应用里面的所有依赖版本； Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） 2、启动器 org.springframework.boot spring-boot-starter-web spring-boot-starter-==web==： ​ spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 2、主程序类，主入口类 /** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */ @SpringBootApplication public class HelloWorldMainApplication { public static void main(String[] args) { // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); } } @SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) public @interface SpringBootApplication { @SpringBootConfiguration:Spring Boot的配置类； ​ 标注在某个类上，表示这是一个Spring Boot的配置类； ​ @Configuration:配置类上来标注这个注解； ​ 配置类 ----- 配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； ​ 以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效； @AutoConfigurationPackage @Import(EnableAutoConfigurationImportSelector.class) public @interface EnableAutoConfiguration { ​ @AutoConfigurationPackage：自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class)： ​ Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class； ==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；== ​ @Import(EnableAutoConfigurationImportSelector.class)； ​ 给容器中导入组件？ ​ EnableAutoConfigurationImportSelector：导入哪些组件的选择器； ​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​ 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作； ​ SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)； ==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们； J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar； ​ ==Spring注解版（谷粒学院）== 6、使用Spring Initializer快速创建Spring Boot项目 1、IDEA：使用 Spring Initializer快速创建项目 IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目； 选择我们需要的模块；向导会联网创建Spring Boot项目； 默认生成的Spring Boot项目； 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中目录结构 static：保存所有的静态资源； js css images； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置； 2、STS使用 Spring Starter Project快速创建项目 二、配置文件 1、配置文件 SpringBoot使用一个全局的配置文件，配置文件名是固定的； •application.properties •application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好； YAML（YAML Ain't Markup Language） ​ YAML A Markup Language：是一个标记语言 ​ YAML isn't Markup Language：不是一个标记语言； 标记语言： ​ 以前的配置文件；大多都使用的是 xxxx.xml文件； ​ YAML：以数据为中心，比json、xml等更适合做配置文件； ​ YAML：配置例子 server: port: 8081 ​ XML： 8081 2、YAML语法： 1、基本语法 k:(空格)v：表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 server: port: 8081 path: /hello 属性和值也是大小写敏感； 2、值的写法 字面量：普通的值（数字，字符串，布尔） ​ k: v：字面直接来写； ​ 字符串默认不用加上单引号或者双引号； ​ \"\"：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: \"zhangsan \\n lisi\"：输出；zhangsan 换行 lisi ​ ''：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 ​ name: ‘zhangsan \\n lisi’：输出；zhangsan \\n lisi 对象、Map（属性和值）（键值对）： ​ k: v：在下一行来写对象的属性和值的关系；注意缩进 ​ 对象还是k: v的方式 friends: lastName: zhangsan age: 20 行内写法： friends: {lastName: zhangsan,age: 18} 数组（List、Set）： 用- 值表示数组中的一个元素 pets: - cat - dog - pig 行内写法 pets: [cat,dog,pig] 3、配置文件值注入 配置文件 person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: {k1: v1,k2: 12} lists: - lisi - zhaoliu dog: name: 小狗 age: 12 javaBean： /** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * */ @Component @ConfigurationProperties(prefix = \"person\") public class Person { private String lastName; private Integer age; private Boolean boss; private Date birth; private Map maps; private List lists; private Dog dog; 我们可以导入配置文件处理器，以后编写配置就有提示了 org.springframework.boot spring-boot-configuration-processor true 1、properties配置文件在idea中默认utf-8可能会乱码 调整 2、@Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 3、配置文件注入值数据校验 @Component @ConfigurationProperties(prefix = \"person\") @Validated public class Person { /** * * * */ //lastName必须是邮箱格式 @Email //@Value(\"${person.last-name}\") private String lastName; //@Value(\"#{11*2}\") private Integer age; //@Value(\"true\") private Boolean boss; private Date birth; private Map maps; private List lists; private Dog dog; 4、@PropertySource&@ImportResource&@Bean @PropertySource：加载指定的配置文件； /** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = \"person\")默认从全局配置文件中获取值； * */ @PropertySource(value = {\"classpath:person.properties\"}) @Component @ConfigurationProperties(prefix = \"person\") //@Validated public class Person { /** * * * */ //lastName必须是邮箱格式 // @Email //@Value(\"${person.last-name}\") private String lastName; //@Value(\"#{11*2}\") private Integer age; //@Value(\"true\") private Boolean boss; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别； 想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上 @ImportResource(locations = {\"classpath:beans.xml\"}) 导入Spring的配置文件让其生效 不来编写Spring的配置文件 SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式 1、配置类@Configuration------>Spring配置文件 2、使用@Bean给容器中添加组件 /** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用标签添加组件 * */ @Configuration public class MyAppConfig { //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02(){ System.out.println(\"配置类@Bean给容器中添加组件了...\"); return new HelloService(); } } 4、配置文件占位符 1、随机数 ${random.value}、${random.int}、${random.long} ${random.int(10)}、${random.int[1024,65536]} 2、占位符获取之前配置的值，如果没有可以是用:指定默认值 person.last-name=张三${random.uuid} person.age=${random.int} person.birth=2017/12/15 person.boss=false person.maps.k1=v1 person.maps.k2=14 person.lists=a,b,c person.dog.name=${person.hello:hello}_dog person.dog.age=15 5、Profile 1、多Profile文件 我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认使用application.properties的配置； 2、yml支持多文档块方式 server: port: 8081 spring: profiles: active: prod --- server: port: 8083 spring: profiles: dev --- server: port: 8084 spring: profiles: prod #指定属于哪个环境 3、激活指定profile ​ 1、在配置文件中指定 spring.profiles.active=dev ​ 2、命令行： ​ java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev； ​ 可以直接在测试的时候，配置传入命令行参数 ​ 3、虚拟机参数； ​ -Dspring.profiles.active=dev 6、配置文件加载位置 springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； ==我们还可以通过spring.config.location来改变默认的配置文件位置== 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar --spring.config.location=G:/application.properties 7、外部配置加载顺序 ==SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置== 1.命令行参数 所有的配置都可以在命令行上进行指定 java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar --server.port=8087 --server.context-path=/abc 多个配置用空格分开； --配置项=值 2.来自java:comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 ==由jar包外向jar包内进行寻找；== ==优先加载带profile== 6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 ==再来加载不带profile== 8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件 9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源； 参考官方文档 8、自动配置原理 配置文件到底能写什么？怎么写？自动配置原理； 配置文件能配置的属性参照 1、自动配置原理： 1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration== 2）、@EnableAutoConfiguration 作用： 利用EnableAutoConfigurationImportSelector给容器中导入一些组件？ 可以查看selectImports()方法的内容； List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置 SpringFactoriesLoader.loadFactoryNames() 扫描所有jar包类路径下 META-INF/spring.factories 把扫描到的这些文件的内容包装成properties对象 从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中 ​ ==将 类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；== # Auto Configure org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\ org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\ org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\ org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\ org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\ org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\ org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\ org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\ org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\ org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\ org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\ org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\ org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\ org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\ org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\ org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\ org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\ org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\ org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\ org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\ org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\ org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\ org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\ org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\ org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\ org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\ org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\ org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\ org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\ org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\ org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\ org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\ org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\ org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\ org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\ org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\ org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\ org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\ org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\ org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\ org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\ org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\ org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\\ org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\\ org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\\ org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\ org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\ org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\ org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\ org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\\ org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\\ org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\\ org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\\ org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\\ org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\ org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\ org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\\ org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\\ org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\\ org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\\ org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\ org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\ org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\ org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\ org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\\ org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\\ org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\\ org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 3）、每一个自动配置类进行自动配置功能； 4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； @Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件 @EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中 @ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效 @ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器； @ConditionalOnProperty(prefix = \"spring.http.encoding\", value = \"enabled\", matchIfMissing = true) //判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的 //即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的； public class HttpEncodingAutoConfiguration { //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) { this.properties = properties; } @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; } 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类 @ConfigurationProperties(prefix = \"spring.http.encoding\") //从配置文件中获取指定的值和bean的属性进行绑定 public class HttpEncodingProperties { public static final Charset DEFAULT_CHARSET = Charset.forName(\"UTF-8\"); 精髓： ​ 1）、SpringBoot启动会加载大量的自动配置类 ​ 2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； ​ 3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） ​ 4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfigurartion：自动配置类； 给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 2、细节 1、@Conditional派生注解（Spring注解版原生的@Conditional作用） 作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类必须在一定的条件下才能生效； 我们怎么知道哪些自动配置类生效； ==我们可以通过启用 debug=true属性；来让控制台打印自动配置报告==，这样我们就可以很方便的知道哪些自动配置类生效； ========================= AUTO-CONFIGURATION REPORT ========================= Positive matches:（自动配置类启用的） ----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) Negative matches:（没有启动，没有匹配成功的自动配置类） ----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition) 三、日志 1、日志框架 小张；开发一个大型系统； ​ 1、System.out.println(\"\")；将关键数据打印在控制台；去掉？写在一个文件？ ​ 2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar； ​ 3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？ ​ 4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar； ​ 5、JDBC---数据库驱动； ​ 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar； ​ 给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层； 市面上的日志框架； JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j.... 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面： SLF4J； 日志实现：Logback； SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘ ​ ==SpringBoot选用 SLF4j和logback；== 2、SLF4j使用 1、如何在系统中使用SLF4j https://www.slf4j.org 以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法； 给系统里面导入slf4j的jar和 logback的实现jar import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class HelloWorld { public static void main(String[] args) { Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(\"Hello World\"); } } 图示； 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件； 2、遗留问题 a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？ 如何让系统中所有的日志都统一到slf4j； ==1、将系统中其他日志框架先排除出去；== ==2、用中间包来替换原有的日志框架；== ==3、我们导入slf4j其他的实现== 3、SpringBoot日志关系 org.springframework.boot spring-boot-starter SpringBoot使用它来做日志功能； org.springframework.boot spring-boot-starter-logging 底层依赖关系 总结： ​ 1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录 ​ 2）、SpringBoot也把其他的日志都替换成了slf4j； ​ 3）、中间替换包？ @SuppressWarnings(\"rawtypes\") public abstract class LogFactory { static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = \"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j\"; static LogFactory logFactory = new SLF4JLogFactory(); ​ 4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？ ​ Spring框架用的是commons-logging； org.springframework spring-core commons-logging commons-logging ==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；== 4、日志使用； 1、默认配置 SpringBoot默认帮我们配置好了日志； //记录器 Logger logger = LoggerFactory.getLogger(getClass()); @Test public void contextLoads() { //System.out.println(); //日志的级别； //由低到高 trace 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --> %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n SpringBoot修改日志的默认配置 logging.level.com.atguigu=trace #logging.path= # 不指定路径在当前项目下生成springboot.log日志 # 可以指定完整的路径； #logging.file=G:/springboot.log # 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件 logging.path=/spring/log # 在控制台输出的日志的格式 logging.pattern.console=%d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n # 指定文件中日志输出的格式 logging.pattern.file=%d{yyyy-MM-dd} === [%thread] === %-5level === %logger{50} ==== %msg%n logging.file logging.path Example Description (none) (none) 只在控制台输出 指定文件名 (none) my.log 输出日志到my.log文件 (none) 指定目录 /var/log 输出到指定目录的 spring.log 文件中 2、指定配置 给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能 可以指定某段配置只在某个环境下生效 如： %d{yyyy-MM-dd HH:mm:ss.SSS} ----> [%thread] ---> %-5level %logger{50} - %msg%n %d{yyyy-MM-dd HH:mm:ss.SSS} ==== [%thread] ==== %-5level %logger{50} - %msg%n 如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误 no applicable action for [springProfile] 5、切换日志框架 可以按照slf4j的日志适配图，进行相关的切换； slf4j+log4j的方式； org.springframework.boot spring-boot-starter-web logback-classic ch.qos.logback log4j-over-slf4j org.slf4j org.slf4j slf4j-log4j12 切换为log4j2 org.springframework.boot spring-boot-starter-web spring-boot-starter-logging org.springframework.boot org.springframework.boot spring-boot-starter-log4j2 四、Web开发 1、简介 使用SpringBoot； 1）、创建SpringBoot应用，选中我们需要的模块； 2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 3）、自己编写业务代码； 自动配置原理？ 这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx xxxxAutoConfiguration：帮我们给容器中自动配置组件； xxxxProperties:配置类来封装配置文件的内容； 2、SpringBoot对静态资源的映射规则； @ConfigurationProperties(prefix = \"spring.resources\", ignoreUnknownFields = false) public class ResourceProperties implements ResourceLoaderAware { //可以设置和静态资源有关的参数，缓存时间等 WebMvcAuotConfiguration： @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { if (!this.resourceProperties.isAddMappings()) { logger.debug(\"Default resource handling disabled\"); return; } Integer cachePeriod = this.resourceProperties.getCachePeriod(); if (!registry.hasMappingForPattern(\"/webjars/**\")) { customizeResourceHandlerRegistration( registry.addResourceHandler(\"/webjars/**\") .addResourceLocations( \"classpath:/META-INF/resources/webjars/\") .setCachePeriod(cachePeriod)); } String staticPathPattern = this.mvcProperties.getStaticPathPattern(); //静态资源文件夹映射 if (!registry.hasMappingForPattern(staticPathPattern)) { customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations( this.resourceProperties.getStaticLocations()) .setCachePeriod(cachePeriod)); } } //配置欢迎页映射 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping( ResourceProperties resourceProperties) { return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); } //配置喜欢的图标 @Configuration @ConditionalOnProperty(value = \"spring.mvc.favicon.enabled\", matchIfMissing = true) public static class FaviconConfiguration { private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) { this.resourceProperties = resourceProperties; } @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() { SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); //所有 **/favicon.ico mapping.setUrlMap(Collections.singletonMap(\"**/favicon.ico\", faviconRequestHandler())); return mapping; } @Bean public ResourceHttpRequestHandler faviconRequestHandler() { ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler .setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; } } ==1）、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；== ​ webjars：以jar包的方式引入静态资源； http://www.webjars.org/ localhost:8080/webjars/jquery/3.3.1/jquery.js 在访问的时候只需要写webjars下面资源的名称即可 org.webjars jquery 3.3.1 ==2）、\"/**\" 访问当前项目的任何资源，都去（静态资源的文件夹）找映射== \"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\" \"/\"：当前项目的根路径 localhost:8080/abc === 去静态资源文件夹里面找abc ==3）、欢迎页； 静态资源文件夹下的所有index.html页面；被\"/**\"映射；== ​ localhost:8080/ 找index页面 ==4）、所有的 **/favicon.ico 都是在静态资源文件下找；== 3、模板引擎 JSP、Velocity、Freemarker、Thymeleaf SpringBoot推荐的Thymeleaf； 语法更简单，功能更强大； 1、引入thymeleaf； org.springframework.boot spring-boot-starter-thymeleaf 2.1.6 切换thymeleaf版本 3.0.9.RELEASE 2.2.2 2、Thymeleaf使用 @ConfigurationProperties(prefix = \"spring.thymeleaf\") public class ThymeleafProperties { private static final Charset DEFAULT_ENCODING = Charset.forName(\"UTF-8\"); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(\"text/html\"); public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; // 只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染； 使用： 1、导入thymeleaf的名称空间 2、使用thymeleaf语法； Title 成功！ 这是显示欢迎信息 3、语法规则 1）、th:text；改变当前元素里面的文本内容； ​ th：任意html属性；来替换原生属性的值 2）、表达式？ Simple expressions:（表达式语法） Variable Expressions: ${...}：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. ${session.foo} 3）、内置的一些工具对象： #execInfo : information about the template being processed. #messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #{…} syntax. #uris : methods for escaping parts of URLs/URIs #conversions : methods for executing the configured conversion service (if any). #dates : methods for java.util.Date objects: formatting, component extraction, etc. #calendars : analogous to #dates , but for java.util.Calendar objects. #numbers : methods for formatting numeric objects. #strings : methods for String objects: contains, startsWith, prepending/appending, etc. #objects : methods for objects in general. #bools : methods for boolean evaluation. #arrays : methods for arrays. #lists : methods for lists. #sets : methods for sets. #maps : methods for maps. #aggregates : methods for creating aggregates on arrays or collections. #ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *{...}：选择表达式：和${}在功能上是一样； 补充：配合 th:object=\"${session.user}： Name: Sebastian. Surname: Pepper. Nationality: Saturn. Message Expressions: #{...}：获取国际化内容 Link URL Expressions: @{...}：定义URL； @{/order/process(execId=${execId},execType='FAST')} Fragment Expressions: ~{...}：片段引用表达式 ... Literals（字面量） Text literals: 'one text' , 'Another one!' ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,… Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is ${name}| Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): - Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , not Comparisons and equality:（比较运算） Comparators: > , = , 4、SpringMVC自动配置 https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications 1. Spring MVC auto-configuration Spring Boot 自动配置好了SpringMVC 以下是SpringBoot对SpringMVC的默认配置:==（WebMvcAutoConfiguration）== Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？）） ContentNegotiatingViewResolver：组合所有的视图解析器的； ==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；== Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars Static index.html support. 静态首页访问 Custom Favicon support (see below). favicon.ico ​ 自动注册了 of Converter, GenericConverter, Formatter beans. Converter：转换器； public String hello(User user)：类型转换使用Converter Formatter 格式化器； 2017.12.17===Date； @Bean @ConditionalOnProperty(prefix = \"spring.mvc\", name = \"date-format\")//在文件中配置日期格式化的规则 public Formatter dateFormatter() { return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件 } ​ ==自己添加的格式化器转换器，我们只需要放在容器中即可== Support for HttpMessageConverters (see below). HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User---Json； HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter； ==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）== ​ Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below). ==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）== 初始化WebDataBinder； 请求数据=====JavaBean； org.springframework.boot.autoconfigure.web：web的所有自动场景； If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 2、扩展SpringMVC ==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc==; 既保留了所有的自动配置，也能用我们扩展的配置； //使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能 @Configuration public class MyMvcConfig extends WebMvcConfigurerAdapter { @Override public void addViewControllers(ViewControllerRegistry registry) { // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(\"/atguigu\").setViewName(\"success\"); } } 原理： ​ 1）、WebMvcAutoConfiguration是SpringMVC的自动配置类 ​ 2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class) @Configuration public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration { private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); //从容器中获取所有的WebMvcConfigurer @Autowired(required = false) public void setConfigurers(List configurers) { if (!CollectionUtils.isEmpty(configurers)) { this.configurers.addWebMvcConfigurers(configurers); //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用； @Override // public void addViewControllers(ViewControllerRegistry registry) { // for (WebMvcConfigurer delegate : this.delegates) { // delegate.addViewControllers(registry); // } } } } ​ 3）、容器中所有的WebMvcConfigurer都会一起起作用； ​ 4）、我们的配置类也会被调用； ​ 效果：SpringMVC的自动配置和我们的扩展配置都会起作用； 3、全面接管SpringMVC； SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了 我们需要在配置类中添加@EnableWebMvc即可； //使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能 @EnableWebMvc @Configuration public class MyMvcConfig extends WebMvcConfigurerAdapter { @Override public void addViewControllers(ViewControllerRegistry registry) { // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(\"/atguigu\").setViewName(\"success\"); } } 原理： 为什么@EnableWebMvc自动配置就失效了； 1）@EnableWebMvc的核心 @Import(DelegatingWebMvcConfiguration.class) public @interface EnableWebMvc { 2）、 @Configuration public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { 3）、 @Configuration @ConditionalOnWebApplication @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class }) //容器中没有这个组件的时候，这个自动配置类才生效 @ConditionalOnMissingBean(WebMvcConfigurationSupport.class) @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10) @AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class }) public class WebMvcAutoConfiguration { 4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来； 5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能； 5、如何修改SpringBoot的默认配置 模式： ​ 1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来； ​ 2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置 ​ 3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置 6、RestfulCRUD 1）、默认访问首页 //使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能 //@EnableWebMvc 不要接管SpringMVC @Configuration public class MyMvcConfig extends WebMvcConfigurerAdapter { @Override public void addViewControllers(ViewControllerRegistry registry) { // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(\"/atguigu\").setViewName(\"success\"); } //所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter(){ WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index.html\").setViewName(\"login\"); } }; return adapter; } } 2）、国际化 1）、编写国际化配置文件； 2）、使用ResourceBundleMessageSource管理国际化资源文件 3）、在页面使用fmt:message取出国际化内容 步骤： 1）、编写国际化配置文件，抽取页面需要显示的国际化消息 2）、SpringBoot自动配置好了管理国际化资源文件的组件； @ConfigurationProperties(prefix = \"spring.messages\") public class MessageSourceAutoConfiguration { /** * Comma-separated list of basenames (essentially a fully-qualified classpath * location), each following the ResourceBundle convention with relaxed support for * slash based locations. If it doesn't contain a package qualifier (such as * \"org.mypackage\"), it will be resolved from the classpath root. */ private String basename = \"messages\"; //我们的配置文件可以直接放在类路径下叫messages.properties； @Bean public MessageSource messageSource() { ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(this.basename)) { //设置国际化资源文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(this.basename))); } if (this.encoding != null) { messageSource.setDefaultEncoding(this.encoding.name()); } messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale); messageSource.setCacheSeconds(this.cacheSeconds); messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat); return messageSource; } 3）、去页面获取国际化的值； Signin Template for Bootstrap Please sign in Username Password [[#{login.remember}]] Sign in © 2017-2018 中文 English 效果：根据浏览器语言设置的信息切换了国际化； 原理： ​ 国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）； @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = \"spring.mvc\", name = \"locale\") public LocaleResolver localeResolver() { if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) { return new FixedLocaleResolver(this.mvcProperties.getLocale()); } AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; } 默认的就是根据请求头带来的区域信息获取Locale进行国际化 4）、点击链接切换国际化 /** * 可以在连接上携带区域信息 */ public class MyLocaleResolver implements LocaleResolver { @Override public Locale resolveLocale(HttpServletRequest request) { String l = request.getParameter(\"l\"); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(l)){ String[] split = l.split(\"_\"); locale = new Locale(split[0],split[1]); } return locale; } @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) { } } @Bean public LocaleResolver localeResolver(){ return new MyLocaleResolver(); } } 3）、登陆 开发期间模板引擎页面修改以后，要实时生效 1）、禁用模板引擎的缓存 # 禁用缓存 spring.thymeleaf.cache=false 2）、页面修改完成以后ctrl+f9：重新编译； 登陆错误消息的显示 4）、拦截器进行登陆检查 拦截器 /** * 登陆检查， */ public class LoginHandlerInterceptor implements HandlerInterceptor { //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { Object user = request.getSession().getAttribute(\"loginUser\"); if(user == null){ //未登陆，返回登陆页面 request.setAttribute(\"msg\",\"没有权限请先登陆\"); request.getRequestDispatcher(\"/index.html\").forward(request,response); return false; }else{ //已登陆，放行请求 return true; } } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { } } 注册拦截器 //所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter(){ WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index.html\").setViewName(\"login\"); registry.addViewController(\"/main.html\").setViewName(\"dashboard\"); } //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) { //super.addInterceptors(registry); //静态资源； *.css , *.js //SpringBoot已经做好了静态资源映射 registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(\"/**\") .excludePathPatterns(\"/index.html\",\"/\",\"/user/login\"); } }; return adapter; } 5）、CRUD-员工列表 实验要求： 1）、RestfulCRUD：CRUD满足Rest风格； URI： /资源名称/资源标识 HTTP请求方式区分对资源CRUD操作 普通CRUD（uri来区分操作） RestfulCRUD 查询 getEmp emp---GET 添加 addEmp?xxx emp---POST 修改 updateEmp?id=xxx&xxx=xx emp/{id}---PUT 删除 deleteEmp?id=1 emp/{id}---DELETE 2）、实验的请求架构; 实验功能 请求URI 请求方式 查询所有员工 emps GET 查询某个员工(来到修改页面) emp/1 GET 来到添加页面 emp GET 添加员工 emp POST 来到修改页面（查出员工进行信息回显） emp/1 GET 修改员工 emp PUT 删除员工 emp/1 DELETE 3）、员工列表： thymeleaf公共页面元素抽取 1、抽取公共片段 &copy; 2011 The Good Thymes Virtual Grocery 2、引入公共片段 ~{templatename::selector}：模板名::选择器 ~{templatename::fragmentname}:模板名::片段名 3、默认效果： insert的公共片段在div标签中 如果使用th:insert等属性进行引入，可以不用写~{}： 行内写法可以加上：[[~{}]];[(~{})]； 三种引入公共片段的th属性： th:insert：将公共片段整个插入到声明引入的元素中 th:replace：将声明引入的元素替换为公共片段 th:include：将被引入的片段的内容包含进这个标签中 &copy; 2011 The Good Thymes Virtual Grocery 引入方式 效果 &copy; 2011 The Good Thymes Virtual Grocery &copy; 2011 The Good Thymes Virtual Grocery &copy; 2011 The Good Thymes Virtual Grocery 引入片段的时候传入参数： Dashboard (current) 6）、CRUD-员工添加 添加页面 LastName Email Gender 男 女 department 1 2 3 4 5 Birth 添加 提交的数据格式不对：生日：日期； 2017-12-12；2017/12/12；2017.12.12； 日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型; 2017-12-12---Date； 类型转换，格式化; 默认日期是按照/的方式； 7）、CRUD-员工修改 修改添加二合一表单 LastName Email Gender 男 女 department 1 Birth 添加 8）、CRUD-员工删除 [[${emp.lastName}]] 编辑 删除 $(\".deleteBtn\").click(function(){ //删除当前员工的 $(\"#deleteEmpForm\").attr(\"action\",$(this).attr(\"del_uri\")).submit(); return false; }); 7、错误处理机制 1）、SpringBoot默认的错误处理机制 默认效果： ​ 1）、浏览器，返回一个默认的错误页面 浏览器发送请求的请求头： ​ 2）、如果是其他客户端，默认响应一个json数据 ​ 原理： ​ 可以参照ErrorMvcAutoConfiguration；错误处理的自动配置； 给容器中添加了以下组件 ​ 1、DefaultErrorAttributes： 帮我们在页面共享信息； @Override public Map getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) { Map errorAttributes = new LinkedHashMap(); errorAttributes.put(\"timestamp\", new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes; } ​ 2、BasicErrorController：处理默认/error请求 @Controller @RequestMapping(\"${server.error.path:${error.path:/error}}\") public class BasicErrorController extends AbstractErrorController { @RequestMapping(produces = \"text/html\")//产生html类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) { HttpStatus status = getStatus(request); Map model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView(\"error\", model) : modelAndView); } @RequestMapping @ResponseBody //产生json数据，其他客户端来到这个方法处理； public ResponseEntity> error(HttpServletRequest request) { Map body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity>(body, status); } ​ 3、ErrorPageCustomizer： @Value(\"${error.path:/error}\") private String path = \"/error\"; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则） ​ 4、DefaultErrorViewResolver： @Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map model) { ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null && SERIES_VIEWS.containsKey(status.series())) { modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); } return modelAndView; } private ModelAndView resolve(String viewName, Map model) { //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = \"error/\" + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) { //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); } //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); } ​ 步骤： ​ 一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被BasicErrorController处理； ​ 1）响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的； protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map model) { //所有的ErrorViewResolver得到ModelAndView for (ErrorViewResolver resolver : this.errorViewResolvers) { ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) { return modelAndView; } } return null; } 2）、如果定制错误响应： 1）、如何定制错误的页面； ​ 1）、有模板引擎的情况下；error/状态码; 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到 对应的页面； ​ 我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）； ​ 页面能获取的信息； ​ timestamp：时间戳 ​ status：状态码 ​ error：错误提示 ​ exception：异常对象 ​ message：异常消息 ​ errors：JSR303数据校验的错误都在这里 ​ 2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找； ​ 3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面； 2）、如何定制错误的json数据； ​ 1）、自定义异常处理&返回定制json数据； @ControllerAdvice public class MyExceptionHandler { @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map handleException(Exception e){ Map map = new HashMap<>(); map.put(\"code\",\"user.notexist\"); map.put(\"message\",e.getMessage()); return map; } } //没有自适应效果... ​ 2）、转发到/error进行自适应响应效果处理 @ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request){ Map map = new HashMap<>(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * Integer statusCode = (Integer) request .getAttribute(\"javax.servlet.error.status_code\"); */ request.setAttribute(\"javax.servlet.error.status_code\",500); map.put(\"code\",\"user.notexist\"); map.put(\"message\",e.getMessage()); //转发到/error return \"forward:/error\"; } 3）、将我们的定制数据携带出去； 出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）； ​ 1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中； ​ 2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到； ​ 容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的； 自定义ErrorAttributes //给容器中加入我们自己定义的ErrorAttributes @Component public class MyErrorAttributes extends DefaultErrorAttributes { @Override public Map getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) { Map map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put(\"company\",\"atguigu\"); return map; } } 最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容， 8、配置嵌入式Servlet容器 SpringBoot默认使用Tomcat作为嵌入式的Servlet容器； 问题？ 1）、如何定制和修改Servlet容器的相关配置； 1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）； server.port=8081 server.context-path=/crud server.tomcat.uri-encoding=UTF-8 //通用的Servlet容器设置 server.xxx //Tomcat的设置 server.tomcat.xxx 2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置 @Bean //一定要将这个定制器加入到容器中 public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer(){ return new EmbeddedServletContainerCustomizer() { //定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableEmbeddedServletContainer container) { container.setPort(8083); } }; } 2）、注册Servlet三大组件【Servlet、Filter、Listener】 由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。 注册三大组件用以下方式 ServletRegistrationBean //注册三大组件 @Bean public ServletRegistrationBean myServlet(){ ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),\"/myServlet\"); return registrationBean; } FilterRegistrationBean @Bean public FilterRegistrationBean myFilter(){ FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList(\"/hello\",\"/myServlet\")); return registrationBean; } ServletListenerRegistrationBean @Bean public ServletListenerRegistrationBean myListener(){ ServletListenerRegistrationBean registrationBean = new ServletListenerRegistrationBean<>(new MyListener()); return registrationBean; } SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet； DispatcherServletAutoConfiguration中： @Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME) @ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME) public ServletRegistrationBean dispatcherServletRegistration( DispatcherServlet dispatcherServlet) { ServletRegistrationBean registration = new ServletRegistrationBean( dispatcherServlet, this.serverProperties.getServletMapping()); //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup( this.webMvcProperties.getServlet().getLoadOnStartup()); if (this.multipartConfig != null) { registration.setMultipartConfig(this.multipartConfig); } return registration; } 2）、SpringBoot能不能支持其他的Servlet容器； 3）、替换为其他嵌入式Servlet容器 默认支持： Tomcat（默认使用） org.springframework.boot spring-boot-starter-web 引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器； Jetty org.springframework.boot spring-boot-starter-web spring-boot-starter-tomcat org.springframework.boot spring-boot-starter-jetty org.springframework.boot Undertow org.springframework.boot spring-boot-starter-web spring-boot-starter-tomcat org.springframework.boot spring-boot-starter-undertow org.springframework.boot 4）、嵌入式Servlet容器自动配置原理； EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？ @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE) @Configuration @ConditionalOnWebApplication @Import(BeanPostProcessorsRegistrar.class) //导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件 //导入了EmbeddedServletContainerCustomizerBeanPostProcessor： //后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作 public class EmbeddedServletContainerAutoConfiguration { @Configuration @ConditionalOnClass({ Servlet.class, Tomcat.class })//判断当前是否引入了Tomcat依赖； @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器 public static class EmbeddedTomcat { @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() { return new TomcatEmbeddedServletContainerFactory(); } } /** * Nested configuration if Jetty is being used. */ @Configuration @ConditionalOnClass({ Servlet.class, Server.class, Loader.class, WebAppContext.class }) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedJetty { @Bean public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() { return new JettyEmbeddedServletContainerFactory(); } } /** * Nested configuration if Undertow is being used. */ @Configuration @ConditionalOnClass({ Servlet.class, Undertow.class, SslClientAuthMode.class }) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedUndertow { @Bean public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() { return new UndertowEmbeddedServletContainerFactory(); } } 1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂） public interface EmbeddedServletContainerFactory { //获取嵌入式的Servlet容器 EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers); } 2）、EmbeddedServletContainer：（嵌入式的Servlet容器） 3）、以TomcatEmbeddedServletContainerFactory为例 @Override public EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers) { //创建一个Tomcat Tomcat tomcat = new Tomcat(); //配置Tomcat的基本环节 File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir(\"tomcat\")); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) { tomcat.getService().addConnector(additionalConnector); } prepareContext(tomcat.getHost(), initializers); //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器 return getTomcatEmbeddedServletContainer(tomcat); } 4）、我们对嵌入式容器的配置修改是怎么生效？ ServerProperties、EmbeddedServletContainerCustomizer EmbeddedServletContainerCustomizer：定制器帮我们修改了Servlet容器的配置？ 怎么修改的原理？ 5）、容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor //初始化之前 @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件 if (bean instanceof ConfigurableEmbeddedServletContainer) { // postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean); } return bean; } private void postProcessBeforeInitialization( ConfigurableEmbeddedServletContainer bean) { //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值； for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) { customizer.customize(bean); } } private Collection getCustomizers() { if (this.customizers == null) { // Look up does not include the parent context this.customizers = new ArrayList( this.beanFactory //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件 .getBeansOfType(EmbeddedServletContainerCustomizer.class, false, false) .values()); Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); } return this.customizers; } ServerProperties也是定制器 步骤： 1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】 2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor； 只要是嵌入式的Servlet容器工厂，后置处理器就工作； 3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法 5）、嵌入式Servlet容器启动原理； 什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat； 获取嵌入式的Servlet容器工厂： 1）、SpringBoot应用启动运行run方法 2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：AnnotationConfigApplicationContext 3）、refresh(context);刷新刚才创建好的ioc容器； public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try { // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); } } } 4）、 onRefresh(); web的ioc容器重写了onRefresh方法 5）、webioc容器会创建嵌入式的Servlet容器；createEmbeddedServletContainer(); 6）、获取嵌入式的Servlet容器工厂： EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory(); ​ 从ioc容器中获取EmbeddedServletContainerFactory 组件；TomcatEmbeddedServletContainerFactory创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置； 7）、使用容器工厂获取嵌入式的Servlet容器：this.embeddedServletContainer = containerFactory .getEmbeddedServletContainer(getSelfInitializer()); 8）、嵌入式的Servlet容器创建对象并启动Servlet容器； 先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来； ==IOC容器启动创建嵌入式的Servlet容器== 9、使用外置的Servlet容器 嵌入式Servlet容器：应用打成可执行的jar ​ 优点：简单、便携； ​ 缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）； 外置的Servlet容器：外面安装Tomcat---应用war包的方式打包； 步骤 1）、必须创建一个war项目；（利用idea创建好目录结构） 2）、将嵌入式的Tomcat指定为provided； org.springframework.boot spring-boot-starter-tomcat provided 3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法 public class ServletInitializer extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) { //传入SpringBoot应用的主程序 return application.sources(SpringBoot04WebJspApplication.class); } } 4）、启动服务器就可以使用； 原理 jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器； war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器； servlet3.0（Spring注解版）： 8.2.4 Shared libraries / runtimes pluggability： 规则： ​ 1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例： ​ 2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名 ​ 3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类； 流程： 1）、启动Tomcat 2）、org\\springframework\\spring-web\\4.3.14.RELEASE\\spring-web-4.3.14.RELEASE.jar!\\META-INF\\services\\javax.servlet.ServletContainerInitializer： Spring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer 3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set>；为这些WebApplicationInitializer类型的类创建实例； 4）、每一个WebApplicationInitializer都调用自己的onStartup； 5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法 6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器 protected WebApplicationContext createRootApplicationContext( ServletContext servletContext) { //1、创建SpringApplicationBuilder SpringApplicationBuilder builder = createSpringApplicationBuilder(); StandardServletEnvironment environment = new StandardServletEnvironment(); environment.initPropertySources(servletContext, null); builder.environment(environment); builder.main(getClass()); ApplicationContext parent = getExistingRootWebApplicationContext(servletContext); if (parent != null) { this.logger.info(\"Root context already created (using as parent).\"); servletContext.setAttribute( WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null); builder.initializers(new ParentContextApplicationContextInitializer(parent)); } builder.initializers( new ServletContextApplicationContextInitializer(servletContext)); builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来 builder = configure(builder); //使用builder创建一个Spring应用 SpringApplication application = builder.build(); if (application.getSources().isEmpty() && AnnotationUtils .findAnnotation(getClass(), Configuration.class) != null) { application.getSources().add(getClass()); } Assert.state(!application.getSources().isEmpty(), \"No SpringApplication sources have been defined. Either override the \" + \"configure method or add an @Configuration annotation\"); // Ensure error pages are registered if (this.registerErrorPageFilter) { application.getSources().add(ErrorPageFilterConfiguration.class); } //启动Spring应用 return run(application); } 7）、Spring的应用就启动并且创建IOC容器 public ConfigurableApplicationContext run(String... args) { StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try { ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); Banner printedBanner = printBanner(environment); context = createApplicationContext(); analyzers = new FailureAnalyzers(context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新IOC容器 refreshContext(context); afterRefresh(context, applicationArguments); listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); } return context; } catch (Throwable ex) { handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); } } ==启动Servlet容器，再启动SpringBoot应用== 五、Docker 1、简介 Docker是一个开源的应用容器引擎；是一个轻量级容器技术； Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像； 运行中的这个镜像称为容器，容器启动是非常快速的。 2、核心概念 docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）； docker客户端(Client)：连接docker主机进行操作； docker仓库(Registry)：用来保存各种打包好的软件镜像； docker镜像(Images)：软件打包好的镜像；放在docker仓库中； docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用 使用Docker的步骤： 1）、安装Docker 2）、去Docker仓库找到这个软件对应的镜像； 3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器； 4）、对容器的启动停止就是对软件的启动停止； 3、安装Docker 1）、安装linux虚拟机 ​ 1）、VMWare、VirtualBox（安装）； ​ 2）、导入虚拟机文件centos7-atguigu.ova； ​ 3）、双击启动linux虚拟机;使用 root/ 123456登陆 ​ 4）、使用客户端连接linux服务器进行命令操作； ​ 5）、设置虚拟机网络； ​ 桥接网络===选好网卡====接入网线； ​ 6）、设置好网络以后使用命令重启虚拟机的网络 service network restart ​ 7）、查看linux的ip地址 ip addr ​ 8）、使用客户端连接linux； 2）、在linux虚拟机上安装docker 步骤： 1、检查内核版本，必须是3.10及以上 uname -r 2、安装docker yum install docker 3、输入y确认安装 4、启动docker [root@localhost ~]# systemctl start docker [root@localhost ~]# docker -v Docker version 1.12.6, build 3e8e77d/1.12.6 5、开机启动docker [root@localhost ~]# systemctl enable docker Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service. 6、停止docker systemctl stop docker 4、Docker常用命令&操作 1）、镜像操作 操作 命令 说明 检索 docker search 关键字 eg：docker search redis 我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。 拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是latest 列表 docker images 查看所有本地镜像 删除 docker rmi image-id 删除指定的本地镜像 https://hub.docker.com/ 2）、容器操作 软件镜像（QQ安装程序）----运行镜像----产生一个容器（正在运行的软件，运行的QQ）； 步骤： 1、搜索镜像 [root@localhost ~]# docker search tomcat 2、拉取镜像 [root@localhost ~]# docker pull tomcat 3、根据镜像启动容器 docker run --name mytomcat -d tomcat:latest 4、docker ps 查看运行中的容器 5、 停止运行中的容器 docker stop 容器的id 6、查看所有的容器 docker ps -a 7、启动容器 docker start 容器id 8、删除一个容器 docker rm 容器id 9、启动一个做了端口映射的tomcat [root@localhost ~]# docker run -d -p 8888:8080 tomcat -d：后台运行 -p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口 10、为了演示简单关闭了linux的防火墙 service firewalld status ；查看防火墙状态 service firewalld stop：关闭防火墙 11、查看容器的日志 docker logs container-name/container-id 更多命令参看 https://docs.docker.com/engine/reference/commandline/docker/ 可以参考每一个镜像的文档 3）、安装MySQL示例 docker pull mysql 错误的启动 [root@localhost ~]# docker run --name mysql01 -d mysql 42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846 mysql退出了 [root@localhost ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 42f09819908b mysql \"docker-entrypoint.sh\" 34 seconds ago Exited (1) 33 seconds ago mysql01 538bde63e500 tomcat \"catalina.sh run\" About an hour ago Exited (143) About an hour ago compassionate_ goldstine c4f1ac60b3fc tomcat \"catalina.sh run\" About an hour ago Exited (143) About an hour ago lonely_fermi 81ec743a5271 tomcat \"catalina.sh run\" About an hour ago Exited (143) About an hour ago sick_ramanujan //错误日志 [root@localhost ~]# docker logs 42f09819908b error: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个 正确的启动 [root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql b874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f [root@localhost ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES b874c56bec49 mysql \"docker-entrypoint.sh\" 4 seconds ago Up 3 seconds 3306/tcp mysql01 做了端口映射 [root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysql ad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434 [root@localhost ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ad10e4bc5c6a mysql \"docker-entrypoint.sh\" 4 seconds ago Up 2 seconds 0.0.0.0:3306->3306/tcp mysql02 几个其他的高级操作 docker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag 把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面 改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql） docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci 指定mysql的一些配置参数 六、SpringBoot与数据访问 1、JDBC org.springframework.boot spring-boot-starter-jdbc mysql mysql-connector-java runtime spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.15.22:3306/jdbc driver-class-name: com.mysql.jdbc.Driver 效果： ​ 默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源； ​ 数据源的相关配置都在DataSourceProperties里面； 自动配置原理： org.springframework.boot.autoconfigure.jdbc： 1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型； 2、SpringBoot默认可以支持； org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、 3、自定义数据源类型 /** * Generic DataSource configuration. */ @ConditionalOnMissingBean(DataSource.class) @ConditionalOnProperty(name = \"spring.datasource.type\") static class Generic { @Bean public DataSource dataSource(DataSourceProperties properties) { //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性 return properties.initializeDataSourceBuilder().build(); } } 4、DataSourceInitializer：ApplicationListener； ​ 作用： ​ 1）、runSchemaScripts();运行建表语句； ​ 2）、runDataScripts();运行插入数据的sql语句； 默认只需要将文件命名为： schema-*.sql、data-*.sql 默认规则：schema.sql，schema-all.sql； 可以使用 schema: - classpath:department.sql 指定位置 5、操作数据库：自动配置了JdbcTemplate操作数据库 2、整合Druid数据源 导入druid数据源 @Configuration public class DruidConfig { @ConfigurationProperties(prefix = \"spring.datasource\") @Bean public DataSource druid(){ return new DruidDataSource(); } //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet(){ ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), \"/druid/*\"); Map initParams = new HashMap<>(); initParams.put(\"loginUsername\",\"admin\"); initParams.put(\"loginPassword\",\"123456\"); initParams.put(\"allow\",\"\");//默认就是允许所有访问 initParams.put(\"deny\",\"192.168.15.21\"); bean.setInitParameters(initParams); return bean; } //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter(){ FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map initParams = new HashMap<>(); initParams.put(\"exclusions\",\"*.js,*.css,/druid/*\"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList(\"/*\")); return bean; } } 3、整合MyBatis org.mybatis.spring.boot mybatis-spring-boot-starter 1.3.1 步骤： ​ 1）、配置数据源相关属性（见上一节Druid） ​ 2）、给数据库建表 ​ 3）、创建JavaBean 4）、注解版 //指定这是一个操作数据库的mapper @Mapper public interface DepartmentMapper { @Select(\"select * from department where id=#{id}\") public Department getDeptById(Integer id); @Delete(\"delete from department where id=#{id}\") public int deleteDeptById(Integer id); @Options(useGeneratedKeys = true,keyProperty = \"id\") @Insert(\"insert into department(departmentName) values(#{departmentName})\") public int insertDept(Department department); @Update(\"update department set departmentName=#{departmentName} where id=#{id}\") public int updateDept(Department department); } 问题： 自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer； @org.springframework.context.annotation.Configuration public class MyBatisConfig { @Bean public ConfigurationCustomizer configurationCustomizer(){ return new ConfigurationCustomizer(){ @Override public void customize(Configuration configuration) { configuration.setMapUnderscoreToCamelCase(true); } }; } } 使用MapperScan批量扫描所有的Mapper接口； @MapperScan(value = \"com.atguigu.springboot.mapper\") @SpringBootApplication public class SpringBoot06DataMybatisApplication { public static void main(String[] args) { SpringApplication.run(SpringBoot06DataMybatisApplication.class, args); } } 5）、配置文件版 mybatis: config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置 mapper-locations: classpath:mybatis/mapper/*.xml 指定sql映射文件的位置 更多使用参照 http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/ 4、整合SpringData JPA 1）、SpringData简介 2）、整合SpringData JPA JPA:ORM（Object Relational Mapping）； 1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系； //使用JPA注解配置映射关系 @Entity //告诉JPA这是一个实体类（和数据表映射的类） @Table(name = \"tbl_user\") //@Table来指定和哪个数据表对应;如果省略默认表名就是user； public class User { @Id //这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键 private Integer id; @Column(name = \"last_name\",length = 50) //这是和数据表对应的一个列 private String lastName; @Column //省略默认列名就是属性名 private String email; 2）、编写一个Dao接口来操作实体类对应的数据表（Repository） //继承JpaRepository来完成对数据库的操作 public interface UserRepository extends JpaRepository { } 3）、基本的配置JpaProperties spring: jpa: hibernate: # 更新或者创建数据表结构 ddl-auto: update # 控制台显示SQL show-sql: true 七、启动配置原理 几个重要的事件回调机制 配置在META-INF/spring.factories ApplicationContextInitializer SpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner CommandLineRunner 启动流程： 1、创建SpringApplication对象 initialize(sources); private void initialize(Object[] sources) { //保存主配置类 if (sources != null && sources.length > 0) { this.sources.addAll(Arrays.asList(sources)); } //判断当前是否一个web应用 this.webEnvironment = deduceWebEnvironment(); //从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来 setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); //从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //从多个配置类中找到有main方法的主配置类 this.mainApplicationClass = deduceMainApplicationClass(); } 2、运行run方法 public ConfigurableApplicationContext run(String... args) { StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); //获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories SpringApplicationRunListeners listeners = getRunListeners(args); //回调所有的获取SpringApplicationRunListener.starting()方法 listeners.starting(); try { //封装命令行参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); //准备环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); //创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成 Banner printedBanner = printBanner(environment); //创建ApplicationContext；决定创建web的ioc还是普通的ioc context = createApplicationContext(); analyzers = new FailureAnalyzers(context); //准备上下文环境;将environment保存到ioc中；而且applyInitializers()； //applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法 //回调所有的SpringApplicationRunListener的contextPrepared()； // prepareContext(context, environment, listeners, applicationArguments, printedBanner); //prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）； //s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版 //扫描，创建，加载所有组件的地方；（配置类，组件，自动配置） refreshContext(context); //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调 //ApplicationRunner先回调，CommandLineRunner再回调 afterRefresh(context, applicationArguments); //所有的SpringApplicationRunListener回调finished方法 listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); } //整个SpringBoot应用启动完成以后返回启动的ioc容器； return context; } catch (Throwable ex) { handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); } } 3、事件监听机制 配置在META-INF/spring.factories ApplicationContextInitializer public class HelloApplicationContextInitializer implements ApplicationContextInitializer { @Override public void initialize(ConfigurableApplicationContext applicationContext) { System.out.println(\"ApplicationContextInitializer...initialize...\"+applicationContext); } } SpringApplicationRunListener public class HelloSpringApplicationRunListener implements SpringApplicationRunListener { //必须有的构造器 public HelloSpringApplicationRunListener(SpringApplication application, String[] args){ } @Override public void starting() { System.out.println(\"SpringApplicationRunListener...starting...\"); } @Override public void environmentPrepared(ConfigurableEnvironment environment) { Object o = environment.getSystemProperties().get(\"os.name\"); System.out.println(\"SpringApplicationRunListener...environmentPrepared..\"+o); } @Override public void contextPrepared(ConfigurableApplicationContext context) { System.out.println(\"SpringApplicationRunListener...contextPrepared...\"); } @Override public void contextLoaded(ConfigurableApplicationContext context) { System.out.println(\"SpringApplicationRunListener...contextLoaded...\"); } @Override public void finished(ConfigurableApplicationContext context, Throwable exception) { System.out.println(\"SpringApplicationRunListener...finished...\"); } } 配置（META-INF/spring.factories） org.springframework.context.ApplicationContextInitializer=\\ com.atguigu.springboot.listener.HelloApplicationContextInitializer org.springframework.boot.SpringApplicationRunListener=\\ com.atguigu.springboot.listener.HelloSpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner @Component public class HelloApplicationRunner implements ApplicationRunner { @Override public void run(ApplicationArguments args) throws Exception { System.out.println(\"ApplicationRunner...run....\"); } } CommandLineRunner @Component public class HelloCommandLineRunner implements CommandLineRunner { @Override public void run(String... args) throws Exception { System.out.println(\"CommandLineRunner...run...\"+ Arrays.asList(args)); } } 八、自定义starter starter： ​ 1、这个场景需要使用到的依赖是什么？ ​ 2、如何编写自动配置 @Configuration //指定这个类是一个配置类 @ConditionalOnXXX //在指定条件成立的情况下自动配置类生效 @AutoConfigureAfter //指定自动配置类的顺序 @Bean //给容器中添加组件 @ConfigurationPropertie结合相关xxxProperties类来绑定相关的配置 @EnableConfigurationProperties //让xxxProperties生效加入到容器中 自动配置类要能加载 将需要启动就加载的自动配置类，配置在META-INF/spring.factories org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\ org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\ ​ 3、模式： 启动器只用来做依赖导入； 专门来写一个自动配置模块； 启动器依赖自动配置；别人只需要引入启动器（starter） mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter 步骤： 1）、启动器模块 4.0.0 com.atguigu.starter atguigu-spring-boot-starter 1.0-SNAPSHOT com.atguigu.starter atguigu-spring-boot-starter-autoconfigurer 0.0.1-SNAPSHOT 2）、自动配置模块 4.0.0 com.atguigu.starter atguigu-spring-boot-starter-autoconfigurer 0.0.1-SNAPSHOT jar atguigu-spring-boot-starter-autoconfigurer Demo project for Spring Boot org.springframework.boot spring-boot-starter-parent 1.5.10.RELEASE UTF-8 UTF-8 1.8 org.springframework.boot spring-boot-starter package com.atguigu.starter; import org.springframework.boot.context.properties.ConfigurationProperties; @ConfigurationProperties(prefix = \"atguigu.hello\") public class HelloProperties { private String prefix; private String suffix; public String getPrefix() { return prefix; } public void setPrefix(String prefix) { this.prefix = prefix; } public String getSuffix() { return suffix; } public void setSuffix(String suffix) { this.suffix = suffix; } } package com.atguigu.starter; public class HelloService { HelloProperties helloProperties; public HelloProperties getHelloProperties() { return helloProperties; } public void setHelloProperties(HelloProperties helloProperties) { this.helloProperties = helloProperties; } public String sayHellAtguigu(String name){ return helloProperties.getPrefix()+\"-\" +name + helloProperties.getSuffix(); } } package com.atguigu.starter; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration @ConditionalOnWebApplication //web应用才生效 @EnableConfigurationProperties(HelloProperties.class) public class HelloServiceAutoConfiguration { @Autowired HelloProperties helloProperties; @Bean public HelloService helloService(){ HelloService service = new HelloService(); service.setHelloProperties(helloProperties); return service; } } 更多SpringBoot整合示例 https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:33 "},"java/boot/springboot_druid.html":{"url":"java/boot/springboot_druid.html","title":"SpringBoot集成Druid不支持多条SQL","summary":"SpringBoot集成Druid不支持多条SQL","keywords":"","body":"SpringBoot集成Druid不支持多条SQL 在DataSource初始化Bean 添加 List proxyFilters = new ArrayList(); WallFilter statFilter = new WallFilter(); WallConfig config = new WallConfig(); config.setMultiStatementAllow(true); // 批量操作 statFilter.setConfig(config); proxyFilters.add(statFilter); druidDataSource.setProxyFilters(proxyFilters); 贴上自己的Config package com.wstro.config; import java.sql.SQLException; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import javax.sql.DataSource; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Value; import org.springframework.boot.web.servlet.FilterRegistrationBean; import org.springframework.boot.web.servlet.ServletRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; import org.springframework.transaction.annotation.EnableTransactionManagement; import com.alibaba.druid.filter.Filter; import com.alibaba.druid.pool.DruidDataSource; import com.alibaba.druid.support.http.StatViewServlet; import com.alibaba.druid.support.http.WebStatFilter; import com.alibaba.druid.wall.WallConfig; import com.alibaba.druid.wall.WallFilter; /** * Druid数据源配置 * * @author Joey * @Email 2434387555@qq.com * */ @Configuration @EnableTransactionManagement // 启注解事务管理 public class DataSourceConfig { private Logger logger = LoggerFactory.getLogger(DataSourceConfig.class); @Value(\"${spring.datasource.url}\") private String dbUrl; @Value(\"${spring.datasource.username}\") private String username; @Value(\"${spring.datasource.password}\") private String password; @Value(\"${spring.datasource.driverClassName}\") private String driverClassName; @Value(\"${spring.datasource.initialSize}\") private int initialSize; @Value(\"${spring.datasource.minIdle}\") private int minIdle; @Value(\"${spring.datasource.maxActive}\") private int maxActive; @Value(\"${spring.datasource.maxWait}\") private int maxWait; @Value(\"${spring.datasource.timeBetweenEvictionRunsMillis}\") private int timeBetweenEvictionRunsMillis; @Value(\"${spring.datasource.minEvictableIdleTimeMillis}\") private int minEvictableIdleTimeMillis; @Value(\"${spring.datasource.validationQuery}\") private String validationQuery; @Value(\"${spring.datasource.testWhileIdle}\") private boolean testWhileIdle; @Value(\"${spring.datasource.testOnBorrow}\") private boolean testOnBorrow; @Value(\"${spring.datasource.testOnReturn}\") private boolean testOnReturn; @Value(\"${spring.datasource.poolPreparedStatements}\") private boolean poolPreparedStatements; @Value(\"${spring.datasource.maxPoolPreparedStatementPerConnectionSize}\") private int maxPoolPreparedStatementPerConnectionSize; @Value(\"${spring.datasource.filters}\") private String filters; @Value(\"${spring.datasource.connectionProperties}\") private String connectionProperties; /** * 注册DruidServlet * * @return ServletRegistrationBean */ @Bean public ServletRegistrationBean druidServletRegistrationBean() { ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(); servletRegistrationBean.setServlet(new StatViewServlet()); servletRegistrationBean.addUrlMappings(\"/druid/*\"); // 白名单： servletRegistrationBean.addInitParameter(\"allow\", \"127.0.0.1\"); // IP黑名单 (存在共同时，deny优先于allow) : 如果满足deny的话提示:Sorry, you are not // permitted to view this page. // 登录查看信息的账号密码. servletRegistrationBean.addInitParameter(\"loginUsername\", \"joey\"); servletRegistrationBean.addInitParameter(\"loginPassword\", \"jay\"); // 是否能够重置数据. servletRegistrationBean.addInitParameter(\"resetEnable\", \"false\"); return servletRegistrationBean; } /** * 注册DruidFilter拦截 * * @return FilterRegistrationBean */ @Bean public FilterRegistrationBean druidFilterRegistrationBean() { FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(); filterRegistrationBean.setFilter(new WebStatFilter()); Map initParams = new HashMap(); // 设置忽略请求 initParams.put(\"exclusions\", \"*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\"); filterRegistrationBean.setInitParameters(initParams); filterRegistrationBean.addUrlPatterns(\"/*\"); return filterRegistrationBean; } /** * 配置DataSource * * @return DataSource * @throws SQLException */ @Bean(initMethod = \"init\", destroyMethod = \"close\") @Primary public DataSource dataSource() throws SQLException { DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setUrl(dbUrl); druidDataSource.setUsername(username); druidDataSource.setPassword(password); druidDataSource.setDriverClassName(driverClassName); // configuration druidDataSource.setInitialSize(initialSize); druidDataSource.setMinIdle(minIdle); druidDataSource.setMaxActive(maxActive); druidDataSource.setMaxWait(maxWait); druidDataSource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis); druidDataSource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis); druidDataSource.setValidationQuery(validationQuery); druidDataSource.setTestWhileIdle(testWhileIdle); druidDataSource.setTestOnBorrow(testOnBorrow); druidDataSource.setTestOnReturn(testOnReturn); druidDataSource.setPoolPreparedStatements(poolPreparedStatements); druidDataSource.setMaxPoolPreparedStatementPerConnectionSize(maxPoolPreparedStatementPerConnectionSize); try { List proxyFilters = new ArrayList(); WallFilter statFilter = new WallFilter(); WallConfig config = new WallConfig(); config.setMultiStatementAllow(true); // 批量操作 statFilter.setConfig(config); proxyFilters.add(statFilter); druidDataSource.setProxyFilters(proxyFilters); druidDataSource.setFilters(filters); } catch (SQLException e) { logger.error(\"druid configuration initialization filter\", e); } druidDataSource.setConnectionProperties(connectionProperties); return druidDataSource; } } properties #JDBC # \\u6570\\u636E\\u5E93\\u8BBF\\u95EE\\u914D\\u7F6E # \\u4E3B\\u6570\\u636E\\u6E90\\uFF0C\\u9ED8\\u8BA4\\u7684 spring.datasource.type=com.alibaba.druid.pool.DruidDataSource spring.datasource.driverClassName=com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://192.168.1.88:3306/wstro?allowMultiQueries=true&useUnicode=true&characterEncoding=UTF-8 spring.datasource.username=root spring.datasource.password=root # \\u4E0B\\u9762\\u4E3A\\u8FDE\\u63A5\\u6C60\\u7684\\u8865\\u5145\\u8BBE\\u7F6E\\uFF0C\\u5E94\\u7528\\u5230\\u4E0A\\u9762\\u6240\\u6709\\u6570\\u636E\\u6E90\\u4E2D # \\u521D\\u59CB\\u5316\\u5927\\u5C0F\\uFF0C\\u6700\\u5C0F\\uFF0C\\u6700\\u5927 spring.datasource.initialSize=5 spring.datasource.minIdle=5 spring.datasource.maxActive=20 # \\u914D\\u7F6E\\u83B7\\u53D6\\u8FDE\\u63A5\\u7B49\\u5F85\\u8D85\\u65F6\\u7684\\u65F6\\u95F4 spring.datasource.maxWait=60000 # \\u914D\\u7F6E\\u95F4\\u9694\\u591A\\u4E45\\u624D\\u8FDB\\u884C\\u4E00\\u6B21\\u68C0\\u6D4B\\uFF0C\\u68C0\\u6D4B\\u9700\\u8981\\u5173\\u95ED\\u7684\\u7A7A\\u95F2\\u8FDE\\u63A5\\uFF0C\\u5355\\u4F4D\\u662F\\u6BEB\\u79D2 spring.datasource.timeBetweenEvictionRunsMillis=60000 # \\u914D\\u7F6E\\u4E00\\u4E2A\\u8FDE\\u63A5\\u5728\\u6C60\\u4E2D\\u6700\\u5C0F\\u751F\\u5B58\\u7684\\u65F6\\u95F4\\uFF0C\\u5355\\u4F4D\\u662F\\u6BEB\\u79D2 spring.datasource.minEvictableIdleTimeMillis=300000 spring.datasource.validationQuery=SELECT 1 FROM DUAL spring.datasource.testWhileIdle=true spring.datasource.testOnBorrow=false spring.datasource.testOnReturn=false # \\u6253\\u5F00PSCache\\uFF0C\\u5E76\\u4E14\\u6307\\u5B9A\\u6BCF\\u4E2A\\u8FDE\\u63A5\\u4E0APSCache\\u7684\\u5927\\u5C0F spring.datasource.poolPreparedStatements=true spring.datasource.maxPoolPreparedStatementPerConnectionSize=20 # \\u914D\\u7F6E\\u76D1\\u63A7\\u7EDF\\u8BA1\\u62E6\\u622A\\u7684filters\\uFF0C\\u53BB\\u6389\\u540E\\u76D1\\u63A7\\u754C\\u9762sql\\u65E0\\u6CD5\\u7EDF\\u8BA1\\uFF0C'wall'\\u7528\\u4E8E\\u9632\\u706B\\u5899 spring.datasource.filters=stat,wall,log4j # \\u901A\\u8FC7connectProperties\\u5C5E\\u6027\\u6765\\u6253\\u5F00mergeSql\\u529F\\u80FD\\uFF1B\\u6162SQL\\u8BB0\\u5F55 spring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000;druid.stat.logSlowSql=true; # \\u5408\\u5E76\\u591A\\u4E2ADruidDataSource\\u7684\\u76D1\\u63A7\\u6570\\u636E #spring.datasource.useGlobalDataSourceStat=true Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:33 "},"java/boot/springboot_index.html":{"url":"java/boot/springboot_index.html","title":"SpringBoot设置默认首页","summary":"SpringBoot设置默认首页","keywords":"","body":"SpringBoot设置默认首页 @Configuration public class DefaultView extends WebMvcConfigurerAdapter{ @Override public void addViewControllers(ViewControllerRegistry registry) { super.addViewControllers(registry); //主页 registry.addViewController(\"/\").setViewName(\"forward:/index\"); } } Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:33 "},"java/boot/ajax_type.html":{"url":"java/boot/ajax_type.html","title":"Ajax请求设置Type为Form-Data","summary":"Ajax请求设置Type为Form-Data","keywords":"","body":"Ajax请求设置Type为Form-Data 在你Ajax请求中加上 headers : { 'Content-Type' : 'application/x-www-form-urlencoded' }, 示例: $.ajax({ type : \"POST\", url : \"../user/repwd\", headers : { 'Content-Type' : 'application/x-www-form-urlencoded' }, data : data, dataType : \"json\", }); Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:33 "},"java/cloud/mycloud.html":{"url":"java/cloud/mycloud.html","title":"SpringCloud2.X","keywords":"","body":"Spring Cloud 一、微服务架构理论入门 推荐入门参照 SpringBoot2.X版和SpringCloud H版 （1）版本选择 技术类型 选择的版本 Spring Cloud Hoxton.SR3 Spring Boot 2.2.5.RELEASE Spring Cloud Alibaba 2.2.0.RELEASE java JAVA8 maven 3.5及以上 mysql 5.7及以上 （2）组件停更/升级/替换 1. 停更不停用 被动修复bugs 不再接受合并请求 不再发布新版本 听课不停学 2. 组件版本 3. 版本升级 （3）官网资料 Spring Cloud官网 Spring Cloud 中文文档 Spring Boot 官网 （4）Eureka服务注册与发现 云端服务发现，一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移。 1. Eureka基础知识 什么是服务治理？ ​ 什么是服务注册? ​ Eureka两组件C/S ​ 2. 单机Eureka构建步骤 建module 改pom文件 写yml配置文件 主启动 业务类 二、微服务架构组件 约定 > 配置 > 编码 什么是服务注册与发现？ 服务注册/发现是微服务架构中不可或缺的重要组件，起初服务都是单节点的甚至是单体服务，不保障高可用性，也不考虑服务的压力承载，服务之间调用单纯的通过接口访问（HttpClient/RestTemplate），直到后面出现了多个节点的分布式架构，起初的解决手段是在服务端负载均衡，同时在网关层收束接口，使不同的请求转发到对应不同端口上，这也是前后分离防止前端跨域的手段之一： 缺点： nginx并不具有服务健康检查的功能，服务调用方在调用一个服务之前是无法知悉服务是否可用的，不考虑这一点分布式的架构高可用的目标就成了一个摆设，解决手段也很简单：对超时或是状态码异常的请求进行重试尝试，请求会被分发到其他可用节点，或者采用服务注册与发现机制察觉健康的服务。 服务注册与发现技术选型 注册中心的解决方案很多，zookeeper、Eureka(当时时Eureka2.0已经闭源，不再更新，因此不建议后续项目使用此组件)、etcd、以及consul等。 Eureka是很优秀的服务注册组件，但是Netflix将2.0闭源后，便已不是最优选择，不过现有的项目使用Eureka 1.x功能已足够使用，不必急于更换技术栈。 zookeeper是一个很强大的k-v组件，功能应是这些技术中最多的，但是我们只需要服务注册的组件，paxos的一致性算法也不如raft高效，保持长连接会对服务造成一定的影响。 etcd其实只是一个k-v系统，需要额外添加对服务发现的支持。 （1）Eureka 注册中心 1. Eureka 自我保护 故障现象 导致原因 怎么禁止自我保护 2. Eureka 停更说明 参见Netflix官网 有关eureka 2.0的现有开源工作已停止。在2.x分支上作为现有工作资料库的一部分发布的代码库和工件被视为使用后果自负。 Eureka 1.x是Netflix服务发现系统的核心部分，仍然是一个活跃的项目。 （2）Zookeeper注册中心 zookeeper是一个分布式协调工具，可以实现注册中心功能 zookeeper服务器取代Eureka服务器，zk作为服务注册中心 1. zookeeper默认端口号 代码访问client的端口号： 2181 leader和flower通信的端口号： 2888 选举leader时通信的端口号： 3888 其他服务与监控中心通信端口： 7070 2. zoo.cfg配置文件详解 zookeeper常用命令 ./zkServer.sh start //启动zookeeper服务端 ./zkServer.sh status //查看zookeeper状态（model显示状态） ./zkCli.sh //启动zookeeper客户端 quit //退出客户端 ./zkServer.sh stop //退出zookeeper服务端 客户端 help //显示所有操作指令 ls / //查看当前znode中所包含的内容 ls2 / //查看当前节点的详细数据 create /sanguo //在此client下创建名称为sanguo的节点 后面可指定节点内容 例子：create /sanguo \"liubei\" create /sanguo/shuguo \"liubei\" //创建多级目录 get /sanguo/shuguo //获取创建节点内的内容 get -w /sanguo/shuguo //获得节点内容，并且设置监听（设置一次监听一次）(当此节点下内容变化有输出) create -e /sanguo/weiguo \"caocao\" //-e创建短暂的节点(client重启后节点消失) create -s /sanguo/weiguo \"caocao\" //-s创建带有序号的节点（序号从总共节点数开始往后排） set /sanguo/shuguo \"diaochan\" //修改节点内的值zhouyu->diaochan ls -w /sanguo //监听子节点的变化 delete /sanguo/wuguo2 //删除/sanguo下的wuguo2 deleteall /sanguo/wuguo //递归删除 （3）Consul 注册中心 1. Consul 简介 Consul是基于GO语言开发的开源工具，主要面向分布式，服务化的系统提供服务注册、服务发现和配置管理的功能。Consul的功能都很实用，其中包括：服务注册/发现、健康检查、Key/Value存储、多数据中心和分布式一致性保证等特性。Consul本身只是一个二进制的可执行文件，所以安装和部署都非常简单。 优点： 基于raft协议，比较简洁，支持健康检查 支持HTTP和DNS协议 ，支持夸数据中心的WAN集群，提供图形界面 跨平台，支持Linux、Windows、Mac. 2. Consul 特性 服务注册与发现： 客户端通过Consul提供服务,其他客户端可以使用Consul发现服务的提供者。使用类似DNS或者HTTP的方式发现。 注意：为什么微服务架构下就需要做服务注册和服务发现呢？ 微服务的目标就是要将原来大一统的系统架构，拆分成细粒度的按功能职责分成的小系统，这样就会出现很多小的系统，部署的节点也会随之增加。试想一下，如果没有一个统一的服务组件来管理各系统间的列表，微服务架构是很难落地实现的。 Consul提供的服务注册/发现功能在数据强一致性和分区容错性上都有非常好的保证，但在集群可用性下就会稍微差一些（相比Euerka来说） 健康监测： 支持多种协议，HTTP、TCP、Docker、Shell脚本定制化 监测，Consul可以快速提醒操作员有关群集中的任何问题。与服务发现的集成可防止将流量路由到不正常的主机，并启用服务级别的断路器。 Key/Value存储： Consul支持Key/Value存储功能，可以将Consul作为配置中心使用，可以将一些公共配置信息配置到Consul，然后通过Consul提供的 HTTP API来获取对应Key的Value。 多数据中心：支持多数据中心(Data Center),多个数据中心之间通过Gossip协议进行数据同步。多数据中心的好处是当某个数据中心出现故障时，其他数据中心可以继续提供服务，提升了可用性。 可视化Web界面 3. Consul 的安装 Consul官网下载链接 使用方式 windows版本：环境变量可以不配置直接在对应的目录打开即可使用 常用命令 查看版本号： consul --version cmd 命令窗口执行启动consul：consul agent -dev consul 自带 UI 界面，打开网址：http://localhost:8500 ，可以看到当前注册的服务界面 cmd 命令窗口执行: consul.exe agent -server ui -bootstrap -client 0.0.0.0 -data-dir=\"E:\\consul\" -bind X.X.X.X 其中X.X.X.X为服务器ip,即可使用http://X.X.X.X:8500 访问ui而不是只能使用localhost连接 基本命令： 1、consul启动 # consul agent -dev # -dev表示开发模式运行，另外还有-server表示服务模式运行 注意：-dev节点的启动不能用于生产环境，因为该模式下不会持久化任何状态，该启动模式仅仅是为了快速便捷的启动单节点consul。 2、查看consul cluster中consul节点的信息 # consul members 说明： Address：节点地址 Status：alive表示节点健康 Type：server运行状态是server状态 DC：dc1表示该节点属于DataCenter1 注意：members命令的输出是基于gossip协议的，并且是最终一致的，也就是说某一个时刻你去运用该命令查到的consul节点的状态信息可能是有误的。 输入 http://127.0.0.1:8500/ui/ 访问Consul。 3、停止服务（优雅退出） # CTRL+C 该节点离开后，会通知cluster中的其他节点 4. Consul的使用 Springcloud consul的官网 （4）注册中心选型 1. CAP理论知识 CAP理论作为分布式系统的基础理论,它描述的是一个分布式系统在以下三个特性中： 一致性（Consistency） 可用性（Availability） 分区容错性（Partition tolerance） 最多满足其中的两个特性。也就是下图所描述的。分布式系统要么满足CA,要么CP，要么AP。无法同时满足CAP。 CAP理论关注粒度是数据，而不是整体系统设计的策略 2. AP(Eureka) 3. CP(Zookeeper/Consul) （5）Ribbon 负载均衡 负载均衡服务调用 1. Ribbon简介 Spring Cloud Ribbon是基的于Netflix Ribbon实现一个基于HTTP和TCP的客户端负载均衡工具。通过Spring Cloud的封装，可以让我们轻松地将面向服务的REST模板请求自动转换成客户端负载均衡的服务调用。 主要功能 Ribbon 提供客户端的软件负载均衡算法和服务调用。 2. 负载均衡理论知识 集中式LB 即在服务的消费方和提供方之间使用独立的LB设施，（可以是硬件：F5,可以是软件：nginx）由该设施负责把访问请求通过某种策略转发至服务器的提供方。 进程内LB 将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可以用，然后自己再从这些地址中选出合适的服务器。 Ribbon就属于进程内的LB,它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。 负载均衡+RestTemplate调用 3. 负载均衡架构 Ribbon在工作中分为两步： 选择EurekaServer,优先选择在同一个区域内负载较少的server 再根据用户指定的策略，在从server取到的服务注册列表中选择一个地址。其中Ribbon提供了多种策略，比如：轮询、随机、根据响应时间加权。 Ribbon其实就是一个软负载均衡的客户端组件，他可以和其他所需请求的客户端结合使用，和eureka结合只是其中的一个实例。 4. RestTemplate的使用 RestTemplate官网 使用方法 SpringBoot2.2.5 版本去除默认的RestTemplate的bean，需要自定义 （1）服务调用方式 RPC：Remote Produce Call远程过程调用，类似的还有RMI。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型代表 Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议，也可以用来进行远程服务调用。缺点是消息封装臃肿，优势是对服务的提供和调用方没有任何技术限定，自由灵活，更符合微服务理念。 （2）POST和Get的区别 Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。 Get传送的数据量较小，这主要是因为受URL长度限制；Post传送的数据量较大，一般被默认为不受限制。 Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。 Get执行效率却比Post方法好。Get是form提交的默认方法。 请求方式 GET POST 参数位置 url的query中 一般在content中，query也可 参数大小 受限于浏览器url大小，一般不超过32K 1G 服务器数据接收 接收1次 根据数据大小，可分多次接收 适用场景（语义） 从服务器端获取数据，不做增删改 向服务器提交数据，如做增删改操作 安全性 参数携带在url中，安全性低 相对于GET请求，安全性更高 GET请求中URL的最大长度限制总结 浏览器 1、IE IE浏览器（Microsoft Internet Explorer） 对url长度限制是2083（2K+53），超过这个限制，则自动截断（若是form提交则提交按钮不起作用）。 2、firefox firefox（火狐浏览器）的url长度限制为 65 536字符，但实际上有效的URL最大长度不少于100,000个字符。 3、chrome chrome（谷歌）的url长度限制超过8182个字符返回本文开头时列出的错误。 4、Safari Safari的url长度限制至少为 80 000 字符。 5、Opera Opera 浏览器的url长度限制为190 000 字符。Opera 9 地址栏中输入190 000字符时依然能正常编辑。 服务器 1、apache apache能接受url长度限制为8 192 字符 2、IIS Microsoft Internet Information Server(IIS)能接受url长度限制为16 384个字符。 这个是可以通过修改的（IIS7）configuration/system.webServer/security/requestFiltering/requestLimits@maxQueryString setting. 3、Perl HTTP::Daemon Perl HTTP::Daemon 至少可以接受url长度限制为8000字符。Perl HTTP::Daemon中限制HTTP request headers的总长度不超过16 384字节(不包括post,file uploads等)。但当url超过8000字符时会返回413错误。 这个限制可以被修改，在Daemon.pm查找16×1024并更改成更大的值。 4、ngnix 可以通过修改配置来改变url请求串的url长度限制。 client_header_buffer_size 默认值：client_header_buffer_size 1k large_client_header_buffers 默认值 ：large_client_header_buffers 4 4k/8k 5. Ribbon负载规则 IRule:根据特定算法从服务列表中选取一个要访问的服务 RoundRobinRule: 轮询 RandomRule ：随机 RetryRule： 先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重试 WeightedResponseTimeRule ： 对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择 BestAvailableRule ： 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务 AvailabilityFilteringRule ：先过滤掉故障实例，再选择并发较小的实例 ZoneAvoidanceRule ：默认规则，复合判断server所在区域的性能和server的可用性选择服务器 如何替换Ribbon的默认规则 Ribbon 负载均衡算法 原理 （6）OpenFeign服务调用 1. OpenFeign简介 what? 官网 ​Feign是一种声明式、模板化的HTTP客户端。在Spring Cloud中使用Feign，可以做到使用HTTP请求访问远程服务，就像调用本地方法一样的，开发者完全感知不到这是在调用远程方法，更感知不到在访问HTTP请求。 Why Feign和OpenFeign两者区别 2. Open调用关系总结 1. openfeign超时控制 OpenFeign默认等待一秒钟，超过后报错 默认Feign客户端只等待一秒钟，但是服务端处理需要超过一秒，导致Feign客户端不想等待了，直接报错，为了避免这种情况，有时候我们需要设置Feign客户端的超时控制。（yml文件开启超时控制） YML文件里需要开启OpenFeign客户端超时控制 ribbon: ReadTimeout: 5000 ConnectTimeout: 5000 2. OpenFeign日志打印功能 Feign 提供了日志打印功能，我们可以通过配置来调整日志打印功能，从而了解Feign中Http请求的细节，简言之就是对Feign接口调用情况进行监控和输出。 Feign日志级别 NONE，不记录（DEFAULT）。 BASIC，仅记录请求方法和URL以及响应状态代码和执行时间。 HEADERS，记录基本信息以及请求和响应标头。 FULL，记录请求和响应的标题，正文和元数据。 （7）Hystrix断路器 分布式系统面临的问题 服务雪崩 通常当你发现一个模块下的某个实例失败后，这时这个模块依然还会接受流量然后这个有问题的模块还调用了其他的模块，这样就发生了级联故障，或者叫雪崩。 1. Hystrix断路器 概述 主要功能 服务降级 服务熔断 接近实时的监控 官网资料 一、Hystrix官宣，停更进维 验证地址 Hystrix Status Hystrix is no longer in active development, and is currently in maintenance mode. 接下来怎么办 被动修复bugs 不再接受合并请求 不再发布新版本 2. Hystrix重要概念 参考原文 服务降级 系统将某些不重要的业务或接口的功能降低，可以只提供部分功能，也可以完全停到所有所有不重要的功能。降级的思想是丢车保帅。 哪些情况会触发降级 程序运行异常 超时 服务熔断触发服务降级 线程池/信号量打满也会导致服务降级 常见的降级方式 系统后门降级：系统预留后门用于降级，比如提供一个降级URL，访问URL时就执行降级指令。缺点：如果服务器数量多，需要一台一台去操作，效率低。 独立系统降级：将降级操作独立到一个单独的系统中，可以实现复杂的权限管理、批量操作等功能。 服务熔断 降级是应对系统自身的故障，而熔断的目的是应对外部系统的故障。比如A服务的X功能依赖B服务的某个接口，当B服务接口响应很慢时，A服务X功能的响应也会被拖慢，进一步导致了A服务的线程都卡在了X功能上，A服务的其它功能也会卡主或拖慢。此时就需要熔断机制，即A服务不在请求B这个接口，A服务内部发现B接口就直接返回错误，从而避免整个A服务被拖慢。 服务的降级->进而熔断->恢复调用链路 实现思路：需要系统有一个统一的API调用层，由API来进行采样或者统计。 服务限流 只允许系统能够承受的访问量进来，超出的会被丢弃。 降级从系统功能优先级角度考虑如何应对故障，而限流则从用户访问压力的角度来考虑如何应对故障。 秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行 常见的限流方式： 基于请求限流：指从外部请求的角度考虑限流。常见的方式有： 限制总量：限制某个指标的累积上限。比如直播间的用户总数上限为100万，超过后用户无法进入。抢购商品数量为100，限制抢购用户上限为1万个，超过或直接拒绝。 限制时间量：限制一段时间内某个指标的上限。例如：一分钟内只允许1000个用户访问。每秒请求峰值为10万。 都需要找到合适的阀值：需要通过性能压测来确定阀值或者逐步优化。 基于资源限流：指从系统内部考虑，找到影响性能的关键资源，对其使用上限限制。常见的内部资源有：连接数、文件句柄、线程数、请求队列、CPU利用率等。例如，使用Netty实现服务器，每个请求先放到请求队列中，业务线程从请求队列中获取任务进行处理，请求队列大小为1000，那么超过该值则直接拒绝。 正因为有上述故障或不佳表现，才有我们的降级/容错/限流等技术诞生 如何解决？解决的要求 超时导致服务器变慢（转圈）——超时不再等待 出错（宕机或程序运行出错）——出错要兜底 解决： 对方服务（8001）超时了，调用者（80）不能一直卡死等待，必须有服务降级 对方服务（8001）down机了，调用者（80）不能一直卡死等待，必须有服务降级 对方服务（8001）OK，调用者（80）自己出故障或有自我要求（自己的等待时间小于服务提供者），自己处理降级 3. 服务熔断原理 服务降级 降低配置 @HystrixCommand 8001先从自身找问题 设置自身调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处理，作服务降级fallback 8001fallback 业务类启用 @HystrixCommand报异常后如何处理 一旦调用服务方法失败并抛出了错误信息后，会自动调用@HystrixCommand标注好的fallbackMethod调用类中的指定方法 主启动类激活 添加新注解@EnableCircuitBreaker 服务熔断 断路器：一句话就是家里保险丝 熔断 大神论文：原文 Hystrix原理总结 断路器执行流程 断路器在什么情况下开始起作用？ 断路器开启或者关闭的条件 当满足一定阀值的时候（默认10秒内超过20个请求次数） 当失败率达到一定的时候（默认10秒内超过50%请求失败） 到达以上阀值，断路器将会开启 当开启的时候，所有请求都不会进行转发 一段时间之后（默认是5秒），这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。重复4和5 断路器打开之后 All配置 服务限流 后面和alibaba的Sentinel对比说明 4. hystrix工作流程 官网原文 工作流程 官网图例 步骤说明 流程说明: 1:每次调用创建一个新的HystrixCommand，把依赖调用封装在run()方法中。 2:执行execute()/queue做同步或异步调用。 3:判断熔断器(circuit-breaker)是否打开，如果打开跳到步骤8，进行降级策略，如果关闭进入步骤。 4:判断线程池/队列/信号量是否跑满，如果跑满进入降级步骤8，否则继续后续步骤。 5:调用HystrixCommand的run方法。运行依赖逻辑 5a:依赖逻辑调用超时，进入步骤8。 6:判断逻辑是否调用成功` 6a:返回成功调用结果 6b:调用出错，进入步骤8。 7:计算熔断器状态，所有的运行状态(成功, 失败, 拒绝,超时)上报给熔断器，用于统计从而判断熔断器状态。 8:getFallback()降级逻辑。 以下四种情况将触发getFallback调用： (1)：run()方法抛出非HystrixBadRequestException异常 (2)：run()方法调用超时 (3)：熔断器开启拦截调用 (4)：线程池/队列/信号量是否跑满 8a:没有实现getFallback的Command将直接抛出异常 8b:fallback降级逻辑调用成功直接返回 8c:降级逻辑调用失败抛出异常 9:返回执行成功结果 5. 服务监控Dashboard 概述 启动URL：http://localhost:9001/hystrix DashBoard如何看？ 7色 1圈 1线 曲线：用来记录两分钟内记录流量的对比变化，可以通过它来观察到流量的上升和下降趋势 图示1 图示2 三、Alibaba 系列组件 （1）Gateway新一代网关 上一代zuul 1.X Spring Cloud Gateway 1. Gateway简介 概述 官网原文 Spring Cloud Gateway 使用的Webflux中的reactor-netty响应式编程组件，底层使用了Netty通讯框架 源码作证 2. Gateway主要功能 反向代理 鉴权 流量控制 熔断 日志监控 微服务架构网关设计 3. zull替代gateway的由来 我们为什么选择Gatway? neflix不太靠谱，zuul2.0一直跳票,迟迟不发布 SpringCloud Gateway具有如下特性 SpringCloud Gateway与Zuul的区别 Zuul1.x模型 GateWay模型】 Spring Framework 5常见问题解答 WebFlux是什么？ Spring官网原文 Spring WebFlux 教程 ​ WebFlux 是 Spring 官方推出来的一个新框架，目前百度百科上还没有对应的词条。 ​ 在没有 WebFlux 之前，也就是传统的命令式编程模式，程序都是按照人工编写的指令（一般情况下，不考虑重排序）一步一步执行下去，下一步的执行需要等待之前的命令完成，也就是说，这条线程一直是在阻塞、执行中交替进行。无论怎么进行优化代码，提升性能，但是本质上还是需要依赖上一个任务的完成。 所以 WebFlux 应用而生，响应式编程千呼万唤终于来临，会对现有的编程模式和思想形成巨大的冲击。WebFlux 将会成为未来的主流！ 4. 三大核心概念 Route(路由) 路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由 Predicate（断言） 参考的是java8的java.util.function.Predicate开发人员可以匹配HTTP请求中的所有内容（例如请求头或请求参数），如果请求与断言相匹配则进行路由 Filter(过滤) 指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。 总结： 5. Gateway工作流程 路由转发+执行过滤器链 6. 入门配置 gateway网关不需要引入web相关的包否则报错 配置方式 在配置文件yml中配置 代码中注入RouteLocator的Bean 1. 通过微服务名实现动态路由 默认情况下Gateway会根据注册中心的服务列表，以注册中心上微服务名为路径创建动态路由进行转发，从而实现动态路由的功能 7. Predicate的使用 每一个Predicate的使用，你可以理解为：当满足这种条件后才会被转发，如果是多个，那就是都满足的情况下被转发。 使用参考 官网原文 Predicate就是为了实现一组匹配规则，让请求过来找到对应的Route进行处理 8. Filter的使用 官网原文 参考文章 自定义全局过滤器 当请求与路由匹配时，过滤Web处理程序会将的所有实例GlobalFilter和所有特定GatewayFilter于路由的实例添加到过滤器链中。该组合的过滤器链按org.springframework.core.Ordered接口排序，您可以通过实现该getOrder()方法进行设置。 由于Spring Cloud Gateway区分过滤器逻辑执行的“前”和“后”阶段（请参见工作原理），因此优先级最高的过滤器是“前”阶段中的第一个，而“后”阶段中的最后一个相对应。 以下清单配置了一个过滤器链： 例子56. ExampleConfiguration.java @Bean public GlobalFilter customFilter() { return new CustomGlobalFilter(); } public class CustomGlobalFilter implements GlobalFilter, Ordered { @Override public Mono filter(ServerWebExchange exchange, GatewayFilterChain chain) { log.info(\"custom global filter\"); return chain.filter(exchange); } @Override public int getOrder() { return -1; } } 9. GateWay 小结 Spring Cloud Gateway 是 Spring 官方基于 Spring 5.0、Spring Boot 2.0 和 Project Reactor 等技术开发的网关，Spring Cloud Gateway 旨在为微服务架构提供一种简单有效的、统一的 API 路由管理方式。 Spring Cloud Gateway 作为 Spring Cloud 生态系中的网关，其目标是替代 Netflix Zuul，它不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全、监控/埋点和限流等。 Spring Cloud Gateway 依赖 Spring Boot 和 Spring WebFlux，基于 Netty 运行。它不能在传统的 servlet 容器中工作，也不能构建成 war 包。 在 Spring Cloud Gateway 中有如下几个核心概念需要我们了解： Route Route 是网关的基础元素，由 ID、目标 URI、断言、过滤器组成。当请求到达网关时，由 Gateway Handler Mapping 通过断言进行路由匹配（Mapping），当断言为真时，匹配到路由。 Predicate Predicate 是 Java 8 中提供的一个函数。输入类型是 Spring Framework ServerWebExchange。它允许开发人员匹配来自 HTTP 的请求，例如请求头或者请求参数。简单来说它就是匹配条件。 Filter Filter 是 Gateway 中的过滤器，可以在请求发出前后进行一些业务上的处理。 （1）Gateway 工作原理 Spring Cloud Gateway 的工作原理跟 Zuul 的差不多，最大的区别就是 Gateway 的 Filter 只有 pre 和 post 两种。下面我们简单了解一下 Gateway 的工作原理图，如图 1 所示。 客户端向 Spring Cloud Gateway 发出请求，如果请求与网关程序定义的路由匹配，则该请求就会被发送到网关 Web 处理程序，此时处理程序运行特定的请求过滤器链。 过滤器之间用虚线分开的原因是过滤器可能会在发送代理请求的前后执行逻辑。所有 pre 过滤器逻辑先执行，然后执行代理请求；代理请求完成后，执行 post 过滤器逻辑。 （2）整合Eureka 创建 Gateway 项目 创建一个 Spring Boot 的 Maven 项目，增加 Spring Cloud Gateway 的依赖，代码如下所示。 org.springframework.boot spring-boot-starter-parent 2.0.6.RELEASE org.springframework.cloud spring-cloud-dependencies Finchley.SR2 pom import org.springframework.cloud spring-cloud-starter-gateway 启动类就按 Spring Boot 的方式即可，无须添加额外的注解。代码如下所示。 @SpringBootApplication public class App { public static void main(String[] args) { SpringApplication.run(App.class, args); } } 路由转发示例 下面来实现一个最简单的转发功能——基于 Path 的匹配转发功能。 Gateway 的路由配置对 yml 文件支持比较好，我们在 resources 下建一个 application.yml 的文件，内容如下： server: port: 2001 spring: cloud: gateway: routes: - id: path_route uri: http://c.biancheng.net predicates: - Path=/spring_cloud 当你访问 http://localhost:2001/spring_cloud 的时候就会转发到 http://c.biancheng.net/spring_cloud。 如果我们要支持多级 Path，配置方式跟 Zuul 中一样，在后面加上两个*号即可，比如： - id: path_route2 uri: http://c.biancheng.net predicates: - Path=/spring_cloud/** 这样一来，上面的配置就可以支持多级 Path，比如访问 http://localhost:2001/spring_cloud/view/1 的时候就会转发到 http://c.biancheng.net/spring_cloud/view/1。 整合 Eureka 路由 添加 Eureka Client 的依赖，代码如下所示。 org.springframework.cloud spring-cloud-starter-netflix-eureka-client 配置基于 Eureka 的路由： - id: user-service uri: lb://user-service predicates: - Path=/user-service/** uri 以lb：//开头（lb 代表从注册中心获取服务），后面接的就是你需要转发到的服务名称，这个服务名称必须跟 Eureka 中的对应，否则会找不到服务，错误代码如下： org.springframework.cloud.gateway.support.NotFoundException: Unable to find instance for user-service1 整合 Eureka 的默认路由 Zuul 默认会为所有服务都进行转发操作，我们只需要在访问路径上指定要访问的服务即可，通过这种方式就不用为每个服务都去配置转发规则，当新加了服务的时候，不用去配置路由规则和重启网关。 在 Spring Cloud Gateway 中当然也有这样的功能，通过配置即可开启，配置如下： spring: cloud: gateway: discovery: locator: enabled: true 开启之后我们就可以通过地址去访问服务了，格式如下： http://网关地址/服务名称(大写)/** http://localhost:2001/USER-SERVICE/user/get?id=1 这个大写的名称还是有很大的影响，如果我们从 Zuul 升级到 Spring Cloud Gateway 的话意味着请求地址有改变，或者重新配置每个服务的路由地址，通过源码笔者发现可以做到兼容处理，再增加一个配置即可： spring: cloud: gateway: discovery: locator: lowerCaseServiceId: true 配置完成之后我们就可以通过小写的服务名称进行访问了，如下所示： http://网关地址/服务名称(小写)/** http://localhost:2001/user-service/user/get?id=1 注意：开启小写服务名称后大写的服务名称就不能使用，两者只能选其一。 配置源码在 org.springframework.cloud.gateway.discovery.DiscoveryLocatorProperties 类中，代码所示。 @ConfigurationProperties(\"spring.cloud.gateway.discovery.locator\") public class DiscoveryLocatorProperties { /** * 服务名称小写配置, 默认为false * */ private boolean lowerCaseServiceId = false; } （3）断言工厂 Spring Cloud Gateway 内置了许多路由断言工厂，可以通过配置的方式直接使用，也可以组合使用多个路由断言工厂。接下来为大家介绍几个常用的路由断言工厂类。 1）Path 路由断言工厂 Path 路由断言工厂接收一个参数，根据 Path 定义好的规则来判断访问的 URI 是否匹配。 spring: cloud: gateway: routes: - id: host_route uri: http://c.biancheng.net predicates: - Path=/blog/detail/{segment} 如果请求路径为 /blog/detail/xxx，则此路由将匹配。也可以使用正则，例如 /blog/detail/** 来匹配 /blog/detail/ 开头的多级 URI。 我们访问本地的网关：http://localhost:2001/blog/detail/36185 ，可以看到显示的是 http://c.biancheng.net/blog/detail/36185 对应的内容。 2）Query 路由断言工厂 Query 路由断言工厂接收两个参数，一个必需的参数和一个可选的正则表达式。 spring: cloud: gateway: routes: - id: query_route uri: http://c.biancheng.net predicates: - Query=foo, ba. 如果请求包含一个值与 ba 匹配的 foo 查询参数，则此路由将匹配。bar 和 baz 也会匹配，因为第二个参数是正则表达式。 测试链接：http://localhost:2001/?foo=baz。 3）Method 路由断言工厂 Method 路由断言工厂接收一个参数，即要匹配的 HTTP 方法。 spring: cloud: gateway: routes: - id: method_route uri: http://baidu.com predicates: - Method=GET 4）Header 路由断言工厂 Header 路由断言工厂接收两个参数，分别是请求头名称和正则表达式。 spring: cloud: gateway: routes: - id: header_route uri: http://example.org predicates: - Header=X-Request-Id, \\d+ 如果请求中带有请求头名为 x-request-id，其值与 \\d+ 正则表达式匹配（值为一个或多个数字），则此路由匹配。 如果你想学习更多路由断言工厂的用法，可以参考官方文档进行学习。 自定义路由断言工厂 自定义路由断言工厂需要继承 AbstractRoutePredicateFactory 类，重写 apply 方法的逻辑。 在 apply 方法中可以通过 exchange.getRequest() 拿到 ServerHttpRequest 对象，从而可以获取到请求的参数、请求方式、请求头等信息。 apply 方法的参数是自定义的配置类，在使用的时候配置参数，在 apply 方法中直接获取使用。 命名需要以 RoutePredicateFactory 结尾，比如 CheckAuthRoutePredicateFactory，那么在使用的时候 CheckAuth 就是这个路由断言工厂的名称。代码如下所示。 @Component public class CheckAuthRoutePredicateFactory extends AbstractRoutePredicateFactory { public CheckAuthRoutePredicateFactory() { super(Config.class); } @Override public Predicate apply(Config config) { return exchange -> { System.err.println(\"进入了CheckAuthRoutePredicateFactory\\t\" + config.getName()); if (config.getName().equals(\"zhangsan\")) { return true; } return false; }; } public static class Config { private String name; public void setName(String name) { this.name = name; } public String getName() { return name; } } } 使用示例如下所示： spring: cloud: gateway: routes: - id: customer_route uri: http://c.biancheng.net predicates: - name: CheckAuth args: name: zhangsan （4）过滤工厂 GatewayFilter Factory 是 Spring Cloud Gateway 中提供的过滤器工厂。Spring Cloud Gateway 的路由过滤器允许以某种方式修改传入的 HTTP 请求或输出的 HTTP 响应，只作用于特定的路由。 Spring Cloud Gateway 中内置了很多过滤器工厂，直接采用配置的方式使用即可，同时也支持自定义 GatewayFilter Factory 来实现更复杂的业务需求。 spring: cloud: gateway: routes: - id: add_request_header_route uri: http://c.biancheng.net filters: - AddRequestHeader=X-Request-Foo, Bar 接下来为大家介绍几个常用的过滤器工厂类。 1. AddRequestHeader 过滤器工厂 通过名称我们可以快速明白这个过滤器工厂的作用是添加请求头。 符合规则匹配成功的请求，将添加 X-Request-Foo：bar 请求头，将其传递到后端服务中，后方服务可以直接获取请求头信息。代码如下所示。 @GetMapping(\"/hello\") public String hello(HttpServletRequest request) throws Exception { System.err.println(request.getHeader(\"X-Request-Foo\")); return \"success\"; } 2. RemoveRequestHeader 过滤器工厂 RemoveRequestHeader 是移除请求头的过滤器工厂，可以在请求转发到后端服务之前进行 Header 的移除操作。 spring: cloud: gateway: routes: - id: removerequestheader_route uri: http://c.biancheng.net - RemoveRequestHeader=X-Request-Foo 3. SetStatus 过滤器工厂 SetStatus 过滤器工厂接收单个状态，用于设置 Http 请求的响应码。它必须是有效的 Spring Httpstatus（org.springframework.http.HttpStatus）。它可以是整数值 404 或枚举类型 NOT_FOUND。 spring: cloud: gateway: routes: - id: setstatusint_route uri: http://c.biancheng.net filters: - SetStatus=401 4. RedirectTo过滤器工厂 RedirectTo 过滤器工厂用于重定向操作，比如我们需要重定向到百度。 spring: cloud: gateway: routes: - id: prefixpath_route uri: http://c.biancheng.net filters: - RedirectTo=302, http://baidu.com 以上为大家介绍了几个过滤器工厂的使用，教程后面还会为大家介绍 Retry 重试、RequestRateLimiter 限流、Hystrix 熔断过滤器工厂等内容，其他的大家可以自行参考官方文档进行学习。 自定义Spring Cloud Gateway过滤器工厂 自定义 Spring Cloud Gateway 过滤器工厂需要继承 AbstractGatewayFilterFactory 类，重写 apply 方法的逻辑。命名需要以 GatewayFilterFactory 结尾，比如 CheckAuthGatewayFilterFactory，那么在使用的时候 CheckAuth 就是这个过滤器工厂的名称。 自定义过滤器工厂代码如下所示。 @Component public class CheckAuth2GatewayFilterFactory extends AbstractGatewayFilterFactory { public CheckAuth2GatewayFilterFactory() { super(Config.class); } @Override public GatewayFilter apply(Config config) { return (exchange, chain) -> { System.err.println(\"进入了CheckAuth2GatewayFilterFactory\" + config.getName()); ServerHttpRequest request = exchange.getRequest().mutate() .build(); return chain.filter(exchange.mutate().request(request).build()); } } public static class Config { private String name; public void setName(String name) { this.name = name; } public String getName() { return name; } } } 使用如下： filters: - name: CheckAuth2 args: name: 张三 如果你的配置是 Key、Value 这种形式的，那么可以不用自己定义配置类，直接继承 AbstractNameValueGatewayFilterFactory 类即可。 AbstractNameValueGatewayFilterFactory 类继承了 AbstractGatewayFilterFactory，定义了一个 NameValueConfig 配置类，NameValueConfig 中有 name 和 value 两个字段。 我们可以直接使用，AddRequestHeaderGatewayFilterFactory、AddRequestParameterGatewayFilterFactory 等都是直接继承的 AbstractNameValueGatewayFilterFactory。 继承 AbstractNameValueGatewayFilterFactory 方式定义过滤器工厂，代码如下所示。 @Component public class CheckAuthGatewayFilterFactory extends AbstractNameValueGatewayFilter-actory { @Override public GatewayFilter apply(NameValueConfig config) { return (exchange, chain) -> { System.err.println(\"进入了CheckAuthGatewayFilterFactory\" + config.getName() + \"\\t\" + config.getValue()); ServerHttpRequest request = exchange.getRequest().mutate().build(); return chain.filter(exchange.mutate().request(request).build()); }; } } 使用如下： filters： - CheckAuth=zhangsan,男 （5）全局过滤器 全局过滤器作用于所有的路由，不需要单独配置，我们可以用它来实现很多统一化处理的业务需求，比如权限认证、IP 访问限制等。 接口定义类 org.springframework.cloud.gateway.filter.GlobalFilter，具体代码如下所示。 public interface GlobalFilter { Mono filter(ServerWebExchange exchange, GatewayFilterChain chain); } Spring Cloud Gateway 自带的 GlobalFilter 实现类有很多，如图 1 所示。 有转发、路由、负载等相关的 GlobalFilter，感兴趣的朋友可以去看下源码自行了解。我们如何通过定义 GlobalFilter 来实现我们的业务逻辑？ 这里给出一个官方文档上的案例，代码如下所示。 @Configuration public class ExampleConfiguration { private Logger log = LoggerFactory.getLogger(ExampleConfiguration.class); @Bean @Order(-1) public GlobalFilter a() { return (exchange, chain) -> { log.info(\"first pre filter\"); return chain.filter(exchange).then(Mono.fromRunnable(() -> { log.info(\"third post filter\"); })); }; } @Bean @Order(0) public GlobalFilter b() { return (exchange, chain) -> { log.info(\"second pre filter\"); return chain.filter(exchange).then(Mono.fromRunnable(() -> { log.info(\"second post filter\"); })); }; } @Bean @Order(1) public GlobalFilter c() { return (exchange, chain) -> { log.info(\"third pre filter\"); return chain.filter(exchange).then(Mono.fromRunnable(() -> { log.info(\"first post filter\"); })); }; } } 上面定义了 3 个 GlobalFilter，通过 @Order 来指定执行的顺序，数字越小，优先级越高。下面就是输出的日志，从日志就可以看出执行的顺序，如下所示。 2019-8-26 16:08:52.406 INFO 55062 --- [ioEventLoop-4-1] c.c.gateway.config.ExampleConfiguration : first pre filter 2019-8-26 16:08:52.406 INFO 55062 --- [ioEventLoop-4-1] c.c.gateway.config.ExampleConfiguration : second pre filter 2019-8-26 16:08:52.407 INFO 55062 --- [ioEventLoop-4-1] c.c.gateway.config.ExampleConfiguration : third pre filter 2019-8-26 16:08:52.437 INFO 55062 --- [ctor-http-nio-7] c.c.gateway.config.ExampleConfiguration : first post filter 2019-8-26 16:08:52.438 INFO 55062 --- [ctor-http-nio-7] c.c.gateway.config.ExampleConfiguration : second post filter 2019-8-26 16:08:52.438 INFO 55062 --- [ctor-http-nio-7] c.c.gateway.config.ExampleConfiguration : third post filter 当 GlobalFilter 的逻辑比较多时，笔者还是推荐大家单独写一个 GlobalFilter 来处理，比如我们要实现对 IP 的访问限制，即不在 IP 白名单中就不能调用的需求。 单独定义只需要实现 GlobalFilter、Ordered 两个接口就可以了，具体代码如下所示。 @Component public class IPCheckFilter implements GlobalFilter, Ordered { @Override public int getOrder() { return 0; } @Override public Mono filter(ServerWebExchange exchange, GatewayFilterChain chain) { HttpHeaders headers = exchange.getRequest().getHeaders(); // 此处写得非常绝对, 只作演示用, 实际中需要采取配置的方式 if (getIp(headers).equals(\"127.0.0.1\")) { ServerHttpResponse response = exchange.getResponse(); ResponseData data = new ResponseData(); data.setCode(401); data.setMessage(\"非法请求\"); byte[] datas = JsonUtils.toJson(data).getBytes(StandardCharsets.UTF_8); DataBuffer buffer = response.bufferFactory().wrap(datas); response.setStatusCode(HttpStatus.UNAUTHORIZED); response.getHeaders().add(\"Content-Type\", \"application/json;charset=UTF-8\"); return response.writeWith(Mono.just(buffer)); } return chain.filter(exchange); } // 这里从请求头中获取用户的实际IP,根据Nginx转发的请求头获取 private String getIp(HttpHeaders headers) { return \"127.0.0.1\"; } } 过滤的使用虽然比较简单，但作用很大，可以处理很多需求，上面讲的 IP 认证拦截只是冰山一角，更多的功能需要我们自己基于过滤器去实现。 （6）Gateway 实践 限流 熔断回退 跨域 统一异常处理 重试机制 Spring Cloud Gateway 作为新一代网关，在性能上有很大提升，并且附加了诸如限流等实用的功能。本节主要讲解 Gateway 的一些实用功能的实例。 限流实战 开发高并发系统时有三把利器用来保护系统：缓存、降级和限流。API 网关作为所有请求的入口，请求量大，我们可以通过对并发访问的请求进行限速来保护系统的可用性。 目前限流提供了基于 Redis 的实现，我们需要增加对应的依赖，代码如下所示。 org.springframework.boot spring-boot-starter-data-redis-reactive 我们可以通过 KeyResolver 来指定限流的 Key，比如我们需要根据用户来做限流，或是根据 IP 来做限流等。 IP 限流 IP 限流的 Key 指定具体代码如下所示。 @Bean public KeyResolver ipKeyResolver() { return exchange -> Mono.just(exchange.getRequest().getRemoteAddress().getHostName()); } public static String getIpAddr(ServerHttpRequest request) { HttpHeaders headers = request.getHeaders(); List ips = headers.get(\"X-Forwarded-For\"); String ip = \"192.168.1.1\"; if (ips != null && ips.size() > 0) { ip = ips.get(0); } return ip; } 用户限流 根据用户来做限流只需要获取当前请求的用户 ID 或者用户名，代码如下所示。 @Bean KeyResolver userKeyResolver() { return exchange -> Mono.just(exchange.getRequest().getQueryParams().getFirst(\"userId\")); } 接口限流 获取请求地址的 uri 作为限流 Key，代码如下所示。 @Bean KeyResolver apiKeyResolver() { return exchange -> Mono.just(exchange.getRequest().getPath().value()); } 然后配置限流的过滤器信息： server: port: 8084 spring: redis: host: 127.0.0.1 port: 6379 cloud: gateway: routes: - id: fsh-house uri: lb://fsh-house predicates: - Path=/house/** filters: - name: RequestRateLimiter args: redis-rate-limiter.replenishRate: 10 redis-rate-limiter.burstCapacity: 20 key-resolver: \"#{@ipKeyResolver}\" filter 名称必须是 RequestRateLimiter。 redis-rate-limiter.replenishRate：允许用户每秒处理多少个请求。 redis-rate-limiter.burstCapacity：令牌桶的容量，允许在 1s 内完成的最大请求数。 key-resolver：使用 SpEL 按名称引用 bean。 可以访问接口进行测试，这时候 Redis 中会有对应的数据： 127.0.0.1:6379> keys * 1) \"request_rate_limiter.{localhost}.timestamp\" 2) \"request_rate_limiter.{localhost}.tokens\" 大括号中就是我们的限流 Key，这里是 IP，本地的就是 localhost。 timestamp：存储的是当前时间的秒数，也就是 System.currentTimeMillis()/1000 或者 Instant.now().getEpochSecond()。 tokens：存储的是当前这秒钟对应的可用令牌数量。 熔断回退实战 在 Spring Cloud Gateway 中使用 Hystrix 进行回退需要增加 Hystrix 的依赖，代码如下所示。 org.springframework.cloud spring-cloud-starter-netflix-hystrix 内置了 HystrixGatewayFilterFactory 来实现路由级别的熔断，只需要配置即可实现熔断回退功能。配置方式如下所示。 - id: user-service uri: lb://user-service predicates: - Path=/user-service/** filters: - name: Hystrix args: name: fallbackcmd fallbackUri: forward:/fallback 上面配置了一个 Hystrix 过滤器，该过滤器会使用 Hystrix 熔断与回退，原理是将请求包装成 RouteHystrixCommand 执行，RouteHystrixCommand 继承于 com.netflix.hystrix.HystrixObservableCommand。 fallbackUri 是发生熔断时回退的 URI 地址，目前只支持 forward 模式的 URI。如果服务被降级，该请求会被转发到该 URI 中。 在网关中创建一个回退的接口，用于熔断时处理返回给调用方的信息，代码如下所示。 @RestController public class FallbackController { @GetMapping(\"/fallback\") public String fallback() { return \"fallback\"; } } 跨域实战 在 Spring Cloud Gateway 中配置跨域有两种方式，分别是代码配置方式和配置文件方式。 代码配置方式配置跨域，具体代码如下所示。 @Configuration public class CorsConfig { @Bean public WebFilter corsFilter() { return (ServerWebExchange ctx, WebFilterChain chain) -> { ServerHttpRequest request = ctx.getRequest(); if (CorsUtils.isCorsRequest(request)) { HttpHeaders requestHeaders = request.getHeaders(); ServerHttpResponse response = ctx.getResponse(); HttpMethod requestMethod = requestHeaders.getAccessControlRequestMethod(); HttpHeaders headers = response.getHeaders(); headers.add(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, requestHeaders.getOrigin()); headers.addAll(HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS, requestHeaders.getAccessControlRequestHeaders()); if (requestMethod != null) { headers.add(HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS, requestMethod.name()); } headers.add(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS, \"true\"); headers.add(HttpHeaders.ACCESS_CONTROL_EXPOSE_HEADERS, \"*\"); if (request.getMethod() == HttpMethod.OPTIONS) { response.setStatusCode(HttpStatus.OK); return Mono.empty(); } } return chain.filter(ctx); }; } } 配置文件方式配置跨域： spring: cloud: gateway: globalcors: corsConfigurations: '[/**]': allowedOrigins: \"*\" exposedHeaders: - content-type allowedHeaders: - content-type allowCredentials: true allowedMethods: - GET - OPTIONS - PUT - DELETE - POST 统一异常处理 Spring Cloud Gateway 中的全局异常处理不能直接使用 @ControllerAdvice，可以通过跟踪异常信息的抛出，找到对应的源码，自定义一些处理逻辑来匹配业务的需求。 网关是给接口做代理转发的，后端对应的是 REST API，返回数据格式是 JSON。如果不做处理，当发生异常时，Gateway 默认给出的错误信息是页面，不方便前端进行异常处理。 所以我们需要对异常信息进行处理，并返回 JSON 格式的数据给客户端。下面先看实现的代码，后面再跟大家讲一下需要注意的地方。 自定义异常处理逻辑，代码如下所示。 public class JsonExceptionHandler extends DefaultErrorWebExceptionHandler { public JsonExceptionHandler(ErrorAttributes errorAttributes, ResourceProperties resourceProperties, ErrorProperties errorProperties, ApplicationContext applicationContext) { super(errorAttributes, resourceProperties, errorProperties, applicationContext); } /** * 获取异常属性 */ @Override protected Map getErrorAttributes(ServerRequest request, boolean includeStackTrace) { int code = 500; Throwable error = super.getError(request); if (error instanceof org.springframework.cloud.gateway.support.NotFoundException) { code = 404; } return response(code, this.buildMessage(request, error)); } /** * 指定响应处理方法为JSON处理的方法 * * @param errorAttributes */ @Override protected RouterFunction getRoutingFunction(ErrorAttributes errorAttributes) { return RouterFunctions.route(RequestPredicates.all(), this::renderErrorResponse); } /** * 根据code获取对应的HttpStatus * * @param errorAttributes */ @Override protected HttpStatus getHttpStatus(Map errorAttributes) { int statusCode = (int) errorAttributes.get(\"code\"); return HttpStatus.valueOf(statusCode); } /** * 构建异常信息 * * @param request * @param ex * @return */ private String buildMessage(ServerRequest request, Throwable ex) { StringBuilder message = new StringBuilder(\"Failed to handle request [\"); message.append(request.methodName()); message.append(\" \"); message.append(request.uri()); message.append(\"]\"); if (ex != null) { message.append(\": \"); message.append(ex.getMessage()); } return message.toString(); } /** * 构建返回的JSON数据格式 * * @param status 状态码 * @param errorMessage 异常信息 * @return */ public static Map response(int status, String errorMessage) { Map map = new HashMap<>(); map.put(\"code\", status); map.put(\"message\", errorMessage); map.put(\"data\", null); return map; } } 覆盖默认的配置，代码如下所示。 @Configuration @EnableConfigurationProperties({ ServerProperties.class, ResourceProperties.class }) public class ErrorHandlerConfiguration { private final ServerProperties serverProperties; private final ApplicationContext applicationContext; private final ResourceProperties resourceProperties; private final List viewResolvers; private final ServerCodecConfigurer serverCodecConfigurer; public ErrorHandlerConfiguration(ServerProperties serverProperties, ResourceProperties resourceProperties, ObjectProvider> viewResolversProvider, ServerCodecConfigurer serverCodecConfigurer, ApplicationContext applicationContext) { this.serverProperties = serverProperties; this.applicationContext = applicationContext; this.resourceProperties = resourceProperties; this.viewResolvers = viewResolversProvider.getIfAvailable(Collections::emptyList); this.serverCodecConfigurer = serverCodecConfigurer; } @Bean @Order(Ordered.HIGHEST_PRECEDENCE) public ErrorWebExceptionHandler errorWebExceptionHandler(ErrorAttributes errorAttributes) { JsonExceptionHandler exceptionHandler = new JsonExceptionHandler(errorAttributes, this.resourceProperties,this.serverProperties.getError(), this.applicationContext); exceptionHandler.setViewResolvers(this.viewResolvers); exceptionHandler.setMessageWriters(this.serverCodecConfigurer.getWriters()); exceptionHandler.setMessageReaders(this.serverCodecConfigurer.getReaders()); return exceptionHandler; } } 异常时如何返回 JSON 而不是 HTML？ 在 org.springframework.boot.autoconfigure.web.reactive.error.DefaultErrorWeb-Exception-Handler 中的 getRoutingFunction() 方法就是控制返回格式的，源代码如下所示。 @Override protected RouterFunction getRoutingFunction(ErrorAttributes errorAttributes) { return RouterFunctions.route(acceptsTextHtml(), this::renderErrorView).andRoute(RequestPredicates.all(), this::renderErrorResponse); } 这里优先是用 HTML 来显示的，如果想用 JSON 显示改动就可以了，具体代码如下所示。 protected RouterFunction getRoutingFunction(ErrorAttributes errorAttributes) { return RouterFunctions.route(RequestPredicates.all(),this::renderErrorResponse); } getHttpStatus 需要重写 原始的方法是通过 status 来获取对应的 HttpStatus 的，具体代码如下所示。 protected HttpStatus getHttpStatus(Map errorAttributes) { int statusCode = (int) errorAttributes.get(\"status\"); return HttpStatus.valueOf(statusCode); } 如果我们定义的格式中没有 status 字段的话，就会报错，因为找不到对应的响应码。要么返回数据格式中增加 status 子段，要么重写，在笔者的操作中返回的是 code，所以要重写，代码如下所示。 @Override protected HttpStatus getHttpStatus(Map errorAttributes) { int statusCode = (int) errorAttributes.get(\"code\"); return HttpStatus.valueOf(statusCode); } 重试机制 RetryGatewayFilter 是 Spring Cloud Gateway 对请求重试提供的一个 GatewayFilter Factory。配置方式如下所示。 spring: cloud: gateway: routes: - id: zuul-encrypt-service uri: lb://zuul-encrypt-service predicates: - Path=/data/** filters: - name: Retry args: retries: 3 series: SERVER_ERROR 上述代码中具体参数含义如下所示。 retries：重试次数，默认值是 3 次。 series：状态码配置（分段），符合某段状态码才会进行重试逻辑，默认值是 SERVER_ERROR，值是 5，也就是 5XX（5 开头的状态码），共有 5 个值，代码如下所示。 public enum Series { INFORMATIONAL(1), SUCCESSFUL(2), REDIRECTION(3), CLIENT_ERROR(4), SERVER_ERROR(5); } 上述代码中具体参数含义如下所示。 statuses：状态码配置，和 series 不同的是这里是具体状态码的配置，取值请参考 org.springframework.http.HttpStatus。 methods：指定哪些方法的请求需要进行重试逻辑，默认值是 GET 方法，取值代码如下所示。 public enum HttpMethod { GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE; } 上述代码中具体参数含义如下所示。 exceptions：指定哪些异常需要进行重试逻辑。默认值是 java.io.IOException 和 org.springframework.cloud.gateway.support.TimeoutException。 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-28 20:27:24 "},"web/":{"url":"web/","title":"前端开发笔记","keywords":"","body":"前端开发相关笔记 记录前端开发过程中容易出错的地方，及浏览器的一些兼容解决方法 前端开发相关笔记预览：http://zhousiwei.gitee.io/mybook/web/ Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"web/collect.html":{"url":"web/collect.html","title":"移动Web开发技巧汇总","summary":"移动Web开发技巧汇总","keywords":"","body":"移动Web开发技巧汇总 META相关 1. 添加到主屏后的标题（IOS） 2. 启用 WebApp 全屏模式（IOS） 当网站添加到主屏幕后再点击进行启动时，可隐藏地址栏（从浏览器跳转或输入链接进入并没有此效果） 3. 百度禁止转码 通过百度手机打开网页时，百度可能会对你的网页进行转码，往你页面贴上它的广告，非常之恶心。不过我们可以通过这个meta标签来禁止它 百度SiteApp转码声明 4. 设置状态栏的背景颜色（IOS） 设置状态栏的背景颜色，只有在\"apple-mobile-web-app-capable\" content=\"yes\"时生效 content参数： default ：状态栏背景是白色。 black ：状态栏背景是黑色。 black-translucent ：状态栏背景是半透明。 如果设置为 default 或 black ,网页内容从状态栏底部开始。 如果设置为 black-translucent ,网页内容充满整个屏幕，顶部会被状态栏遮挡。 5. 移动端手机号码识别（IOS） 在iOS Safari（其他浏览器和Android均不会）上会对那些看起来像是电话号码的数字处理为电话链接，比如： 7位数字，形如：1234567 带括号及加号的数字，形如：(+86)123456789 双连接线的数字，形如：00-00-00111 11位数字，形如：13800138000 可能还有其他类型的数字也会被识别。我们可以通过如下的meta来关闭电话号码的自动识别： 开启电话功能 123456 开启短信功能： 123456 6. 移动端邮箱识别（Android） 与电话号码的识别一样，在安卓上会对符合邮箱格式的字符串进行识别，我们可以通过如下的meta来管别邮箱的自动识别： 同样地，我们也可以通过标签属性来开启长按邮箱地址弹出邮件发送的功能： dooyoe@gmail.com 7. 添加智能 App 广告条 Smart App Banner（IOS 6+ Safari） 8. IOS Web app启动动画 由于iPad 的启动画面是不包括状态栏区域的。所以启动图片需要减去状态栏区域所对应的方向上的20px大小，相应地在retina设备上要减去40px的大小 （landscape：横屏 | portrait：竖屏） 9. 添加到主屏后的APP图标 指定web app添加到主屏后的图标路径，有两种略微不同的方式： 图标尺寸： 可通过指定size属性来为不同的设备提供不同的图标（但通常来说，我们只需提供一个114 x 114 pixels大小的图标即可 ） 官方说明如下： Create different sizes of your app icon for different devices. If you’re creating a universal app, you need to supply app icons in all four sizes. For iPhone and iPod touch both of these sizes are required: 57 x 57 pixels 114 x 114 pixels (high resolution) For iPad, both of these sizes are required: 72 x 72 pixels 144 x 144 (high resolution) 10. 优先使用最新版本 IE 和 Chrome 11.viewport模板 标题 这里开始内容 常见问题 1、移动端如何定义字体font-family 三大手机系统的字体： ios 系统 默认中文字体是Heiti SC 默认英文字体是Helvetica 默认数字字体是HelveticaNeue 无微软雅黑字体 android 系统 默认中文字体是Droidsansfallback 默认英文和数字字体是Droid Sans 无微软雅黑字体 winphone 系统 默认中文字体是Dengxian(方正等线体) 默认英文和数字字体是Segoe 无微软雅黑字体 各个手机系统有自己的默认字体，且都不支持微软雅黑 如无特殊需求，手机端无需定义中文字体，使用系统默认 英文字体和数字字体可使用 Helvetica ，三种系统都支持 * 移动端定义字体的代码 */ body{font-family:Helvetica;} 2、移动端字体单位font-size选择px还是rem 对于只需要适配手机设备，使用px即可 对于需要适配各种移动设备，使用rem，例如只需要适配iPhone和iPad等分辨率差别比较挺大的设备 rem配置参考： html {font-size:10px} @media screen and (min-width:480px) and (max-width:639px) { html { font-size: 15px } } @media screen and (min-width:640px) and (max-width:719px) { html { font-size: 20px } } @media screen and (min-width:720px) and (max-width:749px) { html { font-size: 22.5px } } @media screen and (min-width:750px) and (max-width:799px) { html { font-size: 23.5px } } @media screen and (min-width:800px) and (max-width:959px) { html { font-size: 25px } } @media screen and (min-width:960px) and (max-width:1079px) { html { font-size: 30px } } @media screen and (min-width:1080px) { html { font-size: 32px } } 3、移动端touch事件(区分webkit 和 winphone) 当用户手指放在移动设备在屏幕上滑动会触发的touch事件 以下支持webkit touchstart——当手指触碰屏幕时候发生。不管当前有多少只手指 touchmove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动 touchend——当手指离开屏幕时触发 touchcancel——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用 以下支持winphone 8 MSPointerDown——当手指触碰屏幕时候发生。不管当前有多少只手指 MSPointerMove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用css的html{-ms-touch-action: none;}可以阻止默认情况的发生：阻止页面滚动 MSPointerUp——当手指离开屏幕时触发 4、移动端click屏幕产生200-300 ms的延迟响应 fastclick可以解决在手机上点击事件的300ms延迟 zepto的touch模块，tap事件也是为了解决在click的延迟问题 触摸事件的响应顺序 1、ontouchstart 2、ontouchmove 3、ontouchend 4、onclick 解决300ms延迟的问题，也可以通过绑定ontouchstart事件，加快对事件的响应 5、什么是Retina显示屏，带来了什么问题 retina：一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个 在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍 那么，前端的应对方案是： 设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/2 //例如图片宽高为：200px*200px，那么写法如下 .css{width:100px;height:100px;background-size:100px 100px;} 其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px .css{font-size:20px} 6、ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉 ios用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0，也就是属性值的最后一位设置为0就可以去除半透明灰色遮罩 a,button,input,textarea{-webkit-tap-highlight-color: rgba(0,0,0,0;)} 7、部分android系统中元素被点击时产生的边框怎么去掉 android用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果 a,button,input,textarea{ -webkit-tap-highlight-color: rgba(0,0,0,0;) -webkit-user-modify:read-write-plaintext-only; } -webkit-user-modify有个副作用，就是输入法不再能够输入多个字符 8、winphone系统a、input标签被点击时产生的半透明灰色背景怎么去掉 9、webkit表单元素的默认外观怎么重置 .css{-webkit-appearance:none;} 10、webkit表单输入框placeholder的颜色值能改变么 input::-webkit-input-placeholder{color:#AAAAAA;} input:focus::-webkit-input-placeholder{color:#EEEEEE;} 11、webkit表单输入框placeholder的文字能换行么 ios可以，android不行~ 12. 关闭iOS键盘首字母自动大写 在iOS中，默认情况下键盘是开启首字母大写的功能的，如果关闭这个功能，可以这样： 13. 关闭iOS输入自动修正 和英文输入默认自动首字母大写那样，IOS还做了一个功能，默认输入法会开启自动修正输入内容，这样的话，用户经常要操作两次。如果不希望开启此功能，我们可以通过input标签属性来关闭掉： 14. 禁止文本缩放 当移动设备横竖屏切换时，文本的大小会重新计算，进行相应的缩放，当我们不需要这种情况时，可以选择禁止： html { 　　 -webkit-text-size-adjust: 100%; } 需要注意的是，PC端的该属性已经被移除，该属性在移动端要生效，必须设置 meta viewport& 15. 移动端如何清除输入框内阴影 在iOS上，输入框默认有内部阴影，但无法使用box-shadow来清除，如果不需要阴影，可以这样关闭： input,textarea { 　　border: 0; /* 方法1 */ 　　-webkit-appearance: none; /* 方法2 */ } 16. 快速回弹滚动 在iOS上如果你想让一个元素拥有像 Native 的滚动效果，你可以这样做： .xxx { overflow: auto; /* auto | scroll */ -webkit-overflow-scrolling: touch; } PS：iScroll用过之后感觉不是很好，有一些诡异的bug，这里推荐另外一个iDangero Swiper，这个插件集成了滑屏滚动的强大功能（支持3D），而且还有回弹滚动的内置滚动条，官方地址：http://www.idangero.us/sliders/swiper/index.php 17. 移动端禁止选中内容 如果你不想用户可以选中页面中的内容，那么你可以在css中禁掉： .user-select-none { -webkit-user-select: none; /* Chrome all / Safari all */ -moz-user-select: none; /* Firefox all （移动端不需要） */ -ms-user-select: none; /* IE 10+ */ } 18. 移动端取消touch高亮效果 在做移动端页面时，会发现所有a标签在触发点击时或者所有设置了伪类 :active 的元素，默认都会在激活状态时，显示高亮框，如果不想要这个高亮，那么你可以通过css以下方法来进行全局的禁止： html { -webkit-tap-highlight-color: rgba(0, 0, 0, 0); } 但这个方法在三星的机子上无效，有一种妥协的方法是把页面非真实跳转链接的a标签换成其它标签，可以解决这个问题。 19. 如何禁止保存或拷贝图像（IOS） 通常当你在手机或者pad上长按图像 img ，会弹出选项 存储图像 或者 拷贝图像，如果你不想让用户这么操作，那么你可以通过以下方法来禁止： img { -webkit-touch-callout: none; } 20.模拟按钮hover效果 移动端触摸按钮的效果，可明示用户有些事情正要发生，是一个比较好体验，但是移动设备中并没有鼠标指针，使用css的hover并不能满足我们的需求，还好国外有个激活css的active效果，代码如下： a{-webkit-tap-highlight-color: rgba(0,0,0,0);} .btn-blue{display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;} .btn-blue:active{background-color: #357AE8;} 按钮 document.addEventListener(\"touchstart\", function(){}, true) 兼容性ios5+、部分android 4+、winphone 8 要做到全兼容的办法，可通过绑定ontouchstart和ontouchend来控制按钮的类名 a{-webkit-tap-highlight-color: rgba(0,0,0,0);} .btn-blue{display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;} .btn-blue-on{background-color: #357AE8;} 按钮 var btnBlue = document.querySelector(\".btn-blue\"); btnBlue.ontouchstart = function(){ this.className = \"btn-blue btn-blue-on\" } btnBlue.ontouchend = function(){ this.className = \"btn-blue\" } 21.屏幕旋转的事件和样式 事件：window.orientation，取值：正负90表示横屏模式、0和180表现为竖屏模式 window.onorientationchange = function(){ switch(window.orientation){ case -90: case 90: alert(\"横屏:\" + window.orientation); case 0: case 180: alert(\"竖屏:\" + window.orientation); break; } } 样式 //竖屏时使用的样式 @media all and (orientation:portrait) { .css{} } //横屏时使用的样式 @media all and (orientation:landscape) { .css{} } 22.audio元素和video元素在ios和andriod中无法自动播放 应对方案：触屏即播 $('html').one('touchstart',function(){ audio.play() }) 23.摇一摇功能 HTML5 deviceMotion：封装了运动传感器数据的事件，可以获取手机运动状态下的运动加速度等数据。 24.手机拍照和上传图片 的accept属性 使用总结： ios 有拍照、录像、选取本地图片功能 部分android只有选取本地图片功能 winphone不支持 input控件默认外观丑陋 25. 消除transition闪屏 .css{ /*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/ -webkit-transform-style: preserve-3d; /*（设置进行转换的元素的背面在面对用户时是否可见：隐藏）*/ -webkit-backface-visibility: hidden; } 开启硬件加速 解决页面闪白 保证动画流畅 .css { -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); } 设计高性能CSS3动画的几个要素 尽可能地使用合成属性transform和opacity来设计CSS3动画 不使用position的left和top来定位 利用translate3D开启GPU加速 26. android 上去掉语音输入按钮 input::-webkit-input-speech-button {display: none} 框架 1. 移动端基础框架 zepto.js 语法与jquery几乎一样，会jquery基本会zepto~ iscroll.js 解决页面不支持弹性滚动，不支持fixed引起的问题~ 实现下拉刷新，滑屏，缩放等功能~ underscore.js 该库提供了一整套函数式编程的实用功能，但是没有扩展任何JavaScript内置对象。 fastclick 加快移动端点击响应时间 animate.css CSS3动画效果库 2. 滑屏框架 适合上下滑屏、左右滑屏等滑屏切换页面的效果 slip.js iSlider.js fullpage.js 3.瀑布流框架 masonry 工具推荐 caniuse 各浏览器支持html5属性查询 paletton调色搭配 关于我 个人博客：https://zhousiwei.gitee.io/ 开发笔记：https://zhousiwei.gitee.io/myBook Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"web/notice.html":{"url":"web/notice.html","title":"前端开发注意事项","summary":"前端开发注意事项","keywords":"","body":"前端开发注意事项 1、清除float浮动 .clearfix { *zoom: 1; } .clearfix:before, .clearfix:after { content: ' '; display: table; } .clearfix:after { clear: both; } 2、radio,checkbox写法 （：这种写法点后面的文字也可选中前面的选择框） 今天 今天 3、在手机端去掉以下标签的各种自带样式 a,select,span,i,input { -webkit-tap-highlight-color: transparent; //无色 -webkit-tap-highlight-color: rgba(0, 0, 0, 0);//这个地方的设置最好是用rgba -webkit-appearance: none; outline: none; border: 0; line-height: normal; background: none; } 4、解决手机web字号不一 body{ -webkit-text-size-adjust:none;} 5、去除ie11输入框的X input[type=text]::-ms-clear { display: none; width : 0; height: 0; } input[type=text]::-ms-reveal { display: none; width : 0; height: 0; } 6、去掉chrome input自动填充颜色 input:-webkit-autofill { box-shadow: 0px 0px 0px 1000px #fff inset !important; } 7、清除chrome下input自动记住密码 8、hack的使用 .box{ background-color:#f1ee18; /*所有识别*/ background-color:#00deff\\9; /*'\\9'IE6、7、8、9、10识别*/ background-color:#00deff\\0; /*'\\0'IE8、9、10识别*/ background-color:#00deff\\9\\0; /*'\\0'IE9、10识别*/ +background-color:#a200ff; /*'+'IE6、7识别*/ _background-color:#1e0bd1; /*'_'IE6识别*/ } IE6能识别*，不能识别 !important; IE7能识别*，能识别!important; FF不能识别*，但能识别!important; \"*\" IE6、IE7可以识别.IE8、FireFox不能. :root #test { background-color:purple\\9; } :root是给ie9的，网上流传了个版本是 :root #test { background-　color:purple\\0;}，这个，新版opera也认识，所以经笔者反复验证最终ie9特有的为:root 选择符 {属性\\9;} @media all and (min-width:0px){ #test {background-color:black\\0;} } 这个是老是跟ie抢着认\\0的神奇的opera，必须加个\\0,不然firefox，chrome，safari也都认识。。。 @media screen and (-webkit-min-device-pixel-ratio:0){ #test {background-color:gray;} }最后这个是浏览器新贵chrome和safari的。 .test:lang(zh-cn){color:#f00;} /* For IE8+ and not IE */ .test:nth-child(1){color:#0ff;} /* For IE9+ and not IE */ “-″减号是IE6专有的hack “\\9″ IE6/IE7/IE8/IE9/IE10都生效 “\\0″ IE8/IE9/IE10都生效，是IE8/9/10的hack “\\9\\0″ 只对IE9/IE10生效，是IE9/10的hack &lt;!--[if IE]&gt;这段文字只在IE浏览器显示&lt;![endif]--&gt; &lt;!--[if IE 6]&gt;这段文字只在IE6浏览器显示&lt;![endif]--&gt; &lt;!--[if gte IE 6]&gt;这段文字只在IE6以上(包括)版本IE浏览器显示&lt;![endif]--&gt; &lt;!--[if !IE 8]&gt;这段文字在非IE8浏览器显示&lt;![endif]--&gt; &lt;!--[if !IE]&gt;这段文字只在非IE浏览器显示&lt;![endif]--&gt; 9、web网站屏幕适配CSS写法 @media screen and (max-width: 800px) { body{ background: #ccc; } } Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"web/node/nodejs.html":{"url":"web/node/nodejs.html","title":"nodejs项目配置文件介绍","summary":"nodejs项目配置文件介绍","keywords":"","body":"nodejs项目配置文件介绍 在nodejs项目开发时几个主要的配置文件写法 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"web/node/gulpfilejs.html":{"url":"web/node/gulpfilejs.html","title":"gulpfile.js","summary":"gulpfilejs","keywords":"","body":"gulpfilejs 项目运行需要的配置文件 根据每个人不同的需求自己添加删除 var gulp = require('gulp'); var browserSync = require('browser-sync'); var reload = browserSync.reload; var plumber = require('gulp-plumber'); var sass = require('gulp-sass'); var path = require('path'); var fs = require('fs'); var data = require('gulp-data'); var jade = require('gulp-jade'); var concat = require('gulp-concat'); var uglify = require('gulp-uglify'); var uglifycss = require('gulp-uglifycss'); var rename = require(\"gulp-rename\"); var gulpCopy = require('gulp-file-copy'); 把jade编译成html，编译过程会寻找对应名字的json文件 gulp.task('templates', function() { return gulp.src('srcs/jade/*.jade') .pipe(plumber()) .pipe(data(function(file) { var json = JSON.parse(fs.readFileSync('srcs/json/' + path.basename(file.path, '.jade') + '.json')); return json; })) .pipe(jade({ pretty: ' ' })) .pipe(gulp.dest('builds')); }); 监听jade的任务需要跟编译的分开 命令语句：gulp jade-watch 只运行这个命令是执行 jade 编译 gulp.task('jade-watch', ['templates'], reload); gulp.task('scss-watch', ['compass'], reload); 把scss编译成css gulp.task('sass', function() { return gulp.src(\"srcs/scss/*.scss\") .pipe(plumber({ errorHandler: function(error) { console.log(error.message); this.emit('end'); } })) .pipe(sass()) .on('error', function(err) {}) .pipe(gulp.dest(\"builds/css\")) .pipe(reload({ stream: true })); }); 压缩js和css gulp.task('jimin', function() { return gulp.src('builds/js/*/*.js') //.pipe(concat('main.js')) 把所有的js合并压缩到main.js里面 .pipe(uglify({ mangle: {except: [\"require\"]} //压塑时过虑掉不想被压塑的关键词 })) .pipe(rename(function(path) { path.basename })) .pipe(gulp.dest('builds/compressed/js')); }); gulp.task('cssmin', function() { gulp.src('builds/css/*.css') .pipe(uglifycss()) .pipe(rename(function(path) { path.basename += '.min' })) .pipe(gulp.dest('builds/compressed/css')); }); gulp.task('compress', ['jsmin', 'cssmin']); 单独运行命令： gulp jimin 只执行js压塑 gulp cssmin 只执行css压塑 gulp compress js和css压塑都执行 注：在不运行gulp时，开户config.rb文件内的 output_style = :compressed 运行compass watch 同样时时压塑css 启动服务器，进行监听 运行命令：gulp 默认启动nodejs项目服务器，时时更新sass和jade编译 gulp.task('default', ['sass', 'templates','jimin','cssmin'], function() { browserSync({ server: 'builds' }); gulp.watch('srcs/scss/*.scss', ['sass']); gulp.watch('srcs/jade/**/*.jade', ['jade-watch']); gulp.watch('srcs/json/*.json', ['jade-watch']); }); Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"web/node/packagejson.html":{"url":"web/node/packagejson.html","title":"package.json","summary":"package.json","keywords":"","body":"package.json 这个文件只需要注意配置dependencies 例： \"browser-sync\": \"^2.8.2\", \"fs\": \"0.0.2\", \"gulp\": \"^3.9.0\", \"gulp-data\": \"^1.2.0\", \"gulp-jade\": \"^1.1.0\", \"gulp-plumber\": \"^1.0.1\", \"gulp-rename\": \"^1.2.2\", \"gulp-sass\": \"^2.0.4\", \"gulp-concat\":\"v2.6.0\", \"gulp-uglify\": \"^1.2.0\", \"gulp-uglifycss\": \"^1.0.4\", \"gulp-wrap-amd\": \"^0.5.0\", \"path\": \"^0.11.14\", \"gulp-file-copy\": \"v0.0.1\" 所需文件版本更新可以查看：https://www.npmjs.com/ Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"web/node/configrb.html":{"url":"web/node/configrb.html","title":"config.rb","summary":"config.rb","keywords":"","body":"config.rb 配置好这个文件里的文件路径，如： http_path = \"/\" css_dir = \"builds/css\" sass_dir = \"srcs/scss\" images_dir = \"builds/images\" javascripts_dir = \"builds/js\" 直接运行命令语句：compass watch 可编译scss 放开代码：# output_style = :compressed&emsp; 去掉前面的“#”这时css能被时时压塑 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"web/node/gitignore.html":{"url":"web/node/gitignore.html","title":".gitignore","summary":".gitignore-忽略不想上传到`git`上的文件","keywords":"","body":"移动Web开发技巧汇总 .gitignore 这个文件是设置忽略不想上传到git上的文件 把不想上传的文件名称直接写进这个文件内就可以 示例： # Logs logs *.log npm-debug.log* yarn-debug.log* yarn-error.log* # Runtime data pids *.pid *.seed *.pid.lock # Directory for instrumented libs generated by jscoverage/JSCover lib-cov # Coverage directory used by tools like istanbul coverage # nyc test coverage .nyc_output # Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files) .grunt # Bower dependency directory (https://bower.io/) bower_components # node-waf configuration .lock-wscript # Compiled binary addons (http://nodejs.org/api/addons.html) build/Release # Dependency directories node_modules/ jspm_packages/ # Typescript v1 declaration files typings/ # Optional npm cache directory .npm # Optional eslint cache .eslintcache # Optional REPL history .node_repl_history # Output of 'npm pack' *.tgz # Yarn Integrity file .yarn-integrity # dotenv environment variables file .env _book .DS_Store Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"web/frame/":{"url":"web/frame/","title":"模块化管理工具及框架","summary":"模块化管理工具","keywords":"","body":"模块化管理工具 常用模块化管理工具的介绍 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"web/frame/webpack.html":{"url":"web/frame/webpack.html","title":"Webpack","summary":"Webpack","keywords":"","body":"Webpack 介绍：Webpack是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过loader的转换，任何形式的资源都可以视作模块，比如CommonJs模块、AMD模块、ES6模块、CSS、图片、JSON、Coffeescript、LESS等。 详细讲解请查看：http://webpackdoc.com/ Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"web/frame/seajs.html":{"url":"web/frame/seajs.html","title":"seajs","summary":"seajs","keywords":"","body":"seajs 介绍：SeaJS是一个遵循CMD规范的JavaScript模块加载框架，可以实现JavaScript的模块化开发及加载机制。 详细API请查看： http://www.zhangxinxu.com/sp/seajs/docs/zh-cn/module-definition.html http://www.zhangxinxu.com/sp/seajs/docs/zh-cn/cheatsheet.html config.js 文件配置 seajs.config({ base: lemon.cdn_asset_url + \"/static/\" + lemon.builds_path, map: [ ['.js', '.js?v=' + (\"undefined\"!=typeof lemon&&lemon.version?lemon.version:(new Date).getTime())] ], alias: { \"jquery\": \"js/libs/min/jquery.1.11.1.min\", \"cookie\": \"js/libs/jquery.cookie\", \"easing\": \"js/libs/jquery.easing\", \"utils\": \"js/components/common/utils\", \"component\": \"js/components/common/component\", \"validate\": \"js/libs/jquery.validate\", \"validate.add\": \"js/libs/jquery.validate.add\", \"pager\": \"js/libs/jquery.pager\", \"layer\": \"js/libs/layer/layer.min\", \"unslider\": \"js/libs/min/unslider.min\", \"layer.ext\": \"js/libs/layer/extend/layer.ext\", \"highStock\": \"js/libs/min/highstock\", \"mousewheel\": \"js/libs/min/jquery.mousewheel.min\", \"countUp\": \"js/libs/countUp\" } }); 注： base 是js文件存放的目录 map 是js文件的后缀和随机版本号 alias 命名：地址 文件引用 define(function (require, exports, module) { var $ = require('jquery'), $layer = require('layer'), LemonUtils = require('utils'), form = $('#loginForm'), popCodeFrom = $('#popCodeFrom'), layerNo = 0; //引用文件 require('validate')($); require('validate.add')($); require('component')($); $(\"#mobile\").telephone(); require(\"./checkcode.js\"); //其他jq用法都一样 $(\"#btnLogin\").on(\"click\", function () { } }); 注：define(function (require, exports, module){}) 跟 $(function(){}) 功能一样 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"web/js/":{"url":"web/js/","title":"js模块","summary":"js模块","keywords":"","body":"js模块 平时用到的一些常见js模块记录笔记 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"web/js/time.html":{"url":"web/js/time.html","title":"时间相关模块","summary":"时间相关模块","keywords":"","body":"时间相关模块 获得服务器时间 function get_server_time(){ var xmlHttp = false; //获取服务器时间 try { xmlHttp = new ActiveXObject(\"Msxml2.XMLHTTP\"); } catch (e) { try { xmlHttp = new ActiveXObject(\"Microsoft.XMLHTTP\"); } catch (e2) { xmlHttp = false; } } if (!xmlHttp && typeof XMLHttpRequest != 'undefined') { xmlHttp = new XMLHttpRequest(); } xmlHttp.open(\"GET\", window.location.href.toString(), false); xmlHttp.setRequestHeader(\"If-None-Match\", \"bytes=-1\"); xmlHttp.setRequestHeader(\"Cache-Control\",\"no-cache\"); xmlHttp.send(null); return new Date(xmlHttp.getResponseHeader(\"Date\")); } 时间格式转化，两者时间相比较 // 对Date的扩展，将 Date 转化为指定格式的String // 月(M)、日(d)、小时(h)、分(m)、秒(s)、季度(q) 可以用 1-2 个占位符， // 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字) // 例子： // (new Date()).Format(\"yyyy-MM-dd hh:mm:ss.S\") ==> 2006-07-02 08:09:04.423 // (new Date()).Format(\"yyyy-M-d h:m:s.S\") ==> 2006-7-2 8:9:4.18 Date.prototype.Format = function(fmt){ //author: meizz var o = { \"M+\" : this.getMonth()+1, //月份 \"d+\" : this.getDate(), //日 \"h+\" : this.getHours(), //小时 \"m+\" : this.getMinutes(), //分 \"s+\" : this.getSeconds(), //秒 \"q+\" : Math.floor((this.getMonth()+3)/3), //季度 \"S\" : this.getMilliseconds() //毫秒 }; if(/(y+)/.test(fmt)) fmt=fmt.replace(RegExp.$1, (this.getFullYear()+\"\").substr(4 - RegExp.$1.length)); for(var k in o) if(new RegExp(\"(\"+ k +\")\").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : ((\"00\"+ o[k]).substr((\"\"+ o[k]).length))); return fmt; } $(function(){ //两个时间之间的比较 function dateCompare(dateStart,dateEnd){ dateStart = dateStart.replace(/\\-/gi,\"/\"); dateEnd = dateEnd.replace(/\\-/gi,\"/\"); var time1 = new Date(dateStart).getTime(); var time2 = new Date(dateEnd).getTime(); if(time2 > time1){ return true; } return false; }//eg 运用场景如： if(dateCompare(new Date($.cookie(\"dataTime\")).Format(\"yyyy-MM-dd\"),new Date().Format(\"yyyy-MM-dd\"))){ //返回true执行这里面的内容 } }) 把时间转化为准备时间 //把时间转换为标准时间 function get_unix_time(dateStr){ var newstr = dateStr.replace(/-/g,'/'); var date = new Date(newstr); //var time_str = date.getTime().toString(); //return time_str.substr(0, 10); return date; } 计算已经开团时间 var indate = $(\"#start_date\").val(); var todate = get_server_time(); //服务器时间 var olddate = get_unix_time(indate); //调用上面的函数把时间转为标准时间 var timepass = 0; function showTime(){ var timelong = (todate - olddate) + timepass; var h = parseInt(timelong/3600000,10); var m = parseInt(timelong%3600000/60000,10); var s = parseInt(timelong%60000/1000); document.getElementById(\"datetime\").innerHTML = (h Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"web/js/commonjs.html":{"url":"web/js/commonjs.html","title":"common.js","summary":"common.js","keywords":"","body":"common.js 相关的正则表达式 function LEMONUtils() {} LEMONUtils.testFn = { isPassword : function(s) { return /(?!^[0-9]+$)(?!^[A-z]+$)(?!^[^A-z0-9]+$)^.{6,20}$/.test(s); }, //邮箱验证 isEmail : function(s) { var isEmailText = /^(?=\\w+([-+.']\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$).{0,30}$/; return isEmailText.test(s); }, //校验手机号码 isMobile : function(s) { var re=/^1[3-8]\\d{9}$/; return re.test(s); }, //校验邮政编码 isZipCode : function(s) { var re = /^[1-9][0-9]{5}$/; return re.test(s); }, //数字 isNumber:function(s) { var re = /^[0-9]*$/; return re.test(s); }, isQQ:function(s) { var re = /^[1-9]*$/; return re.test(s); }, isNickname:function(s){ var re =/^[\\u4E00-\\u9FA5]{2,5}$/; return re.test(s); }, //是否为金额 isMoney: function(s) { var re = /^\\d*(\\.\\d{1,2})?$|^\\d*\\.(\\d{1,2})?$/; return re.test(s); }, // 全中文 isChinese: function(value) { return /^[\\u4e00-\\u9fa5]+$/.test(value); }, // 全数字 isNum: function(value) { return /^[0-9]+$/.test(value); }, // 全英文 isEnglish: function(value) { return /^[a-zA-Z]+$/.test(value); }, // 英文、数字 isPwd: function(value) { return /^[a-zA-Z0-9]+$/.test(value); }, // 英文、数字、汉字 isUname: function(value) { return /^[a-zA-Z0-9\\u4E00-\\u9FA5]+$/.test(value); }, // 是否为RMB isMoney: function(data, isPositive) { return isPositive ? /^\\d+(\\.\\d{1,2})?$/.test(data) && parseFloat(data) > 0 : /^(-)?\\d+(\\.\\d{1,2})?$/.test(data); }, // 身份证 isIdCard: function(idCard) { //15位和18位身份证号码的正则表达式 var regIdCard = /^(^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$)|(^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])((\\d{4})|\\d{3}[Xx])$)$/; //如果通过该验证，说明身份证格式正确，但准确性还需计算 if (regIdCard.test(idCard)) { if (idCard.length == 18) { var idCardWi = new Array(7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2); //将前17位加权因子保存在数组里 var idCardY = new Array(1, 0, 10, 9, 8, 7, 6, 5, 4, 3, 2); //这是除以11后，可能产生的11位余数、验证码，也保存成数组 var idCardWiSum = 0; //用来保存前17位各自乖以加权因子后的总和 for (var i = 0; i -1; i--) { //前15或18位倒序存进数组 newArr.push(first15Num.substr(i, 1)); } var arrJiShu = new Array(); //奇数位*2的积 9 var arrOuShu = new Array(); //偶数位数组 for (var j = 0; j 9 的分割之后的数组个位数 var jishu_child2 = new Array(); //奇数位*2 >9 的分割之后的数组十位数 for (var h = 0; h 9 的分割之后的数组个位数之和 var sumJiShuChild2 = 0; //奇数位*2 >9 的分割之后的数组十位数之和 var sumTotal = 0; for (var m = 0; m 获取url中参数值 function LEMONUtils() {} LEMONUtils.getQueryString = function(name) { var reg = new RegExp(\"(^|&)\" + name + \"=([^&]*)(&|$)\", \"i\"); var r = decodeURIComponent(top.location.search).substr(1).match(reg); if (r != null) return unescape(r[2]); return \"\"; } // 注：运用 var _type = LemonUtils.getQueryString('type'); Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"web/js/ele_opera.html":{"url":"web/js/ele_opera.html","title":"js及jquery获取页面和元素的宽高","summary":"js及jquery获取页面和元素的宽高","keywords":"","body":"js及jquery获取页面和元素的宽高 js： 网页可见区域宽： document.body.clientWidth;(不含滚动条) 网页可见区域高： document.body.clientHeight;(不含滚动条) 网页可见区域宽： document.body.offsetWidth;(包括边线的宽); 网页可见区域高： document.body.offsetHeight;(包括边线的宽); 网页正文全文宽： document.body.scrollWidth; 网页正文全文高： document.body.scrollHeight; 网页被卷去的高(ff)：document.body.scrollTop; 网页被卷去的高(ie): document.documentElement.scrollTop; 网页被卷去的左： document.body.scrollLeft; 网页正文部分上： window.screenTop; 网页正文部分左： window.screenLeft; 某个元素的宽度： obj.offsetWidth; 某个元素的高度： obj.offsetHeight; 某个元素的上边界到body最顶部的距离： obj.offsetTop;(在元素的包含元素不含滚动条的情况下) 某个元素的左边界到body最左边的距离： obj.offsetLeft;(在元素的包含元素不含滚动条的情况下) 返回当前元素的上边界到它的包含元素的上边界的偏移量： obj.offsetTop;(在元素的包含元素含滚动条的情况下) 返回当前元素的左边界到它的包含元素的左边界的偏移量： obj.offsetLeft;(在元素的包含元素含滚动条的情况下) 屏幕分辨率的高： window.screen.height 屏幕分辨率的宽： window.screen.width 屏幕可用工作区高度： window.screen.availHeight 屏幕可用工作区宽度： window.screen.availWidth HTML精确定位：scrollLeft,scrollWidth,clientWidth,offsetWidth scrollHeight: 获取对象的滚动高度。 scrollLeft:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离 scrollTop:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离 scrollWidth:获取对象的滚动宽度 offsetHeight:获取对象相对于版面或由父坐标 offsetParent 属性指定的父坐标的高度 offsetLeft:获取对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置 offsetTop:获取对象相对于版面或由 offsetTop 属性指定的父坐标的计算顶端位置 event.clientX 相对文档的水平座标 event.clientY 相对文档的垂直座标 event.offsetX 相对容器的水平坐标 event.offsetY 相对容器的垂直坐标 document.documentElement.scrollTop 垂直方向滚动的值 event.clientX+document.documentElement.scrollTop 相对文档的水平座标+垂直方向滚动的量 jquery： 获取浏览器显示区域（可视区域）的高度 ： $(window).height(); 获取浏览器显示区域（可视区域）的宽度 ： $(window).width(); 获取页面的文档高度：$(document).height(); 获取页面的文档宽度 ：$(document).width(); 浏览器当前窗口文档body的高度： $(document.body).height(); 浏览器当前窗口文档body的宽度： $(document.body).width(); 获取滚动条到顶部的垂直高度 (即网页被卷上去的高度) ：$(document).scrollTop(); 获取滚动条到左边的垂直宽度 ：$(document).scrollLeft(); 获取或设置元素的宽度：$(obj).width(); 获取或设置元素的高度：$(obj).height(); 获取或设置元素的宽度：$(obj).innerWidth(); (height + padding) 获取或设置元素的高度：$(obj).innerHeight(); (height + padding) 获取或设置元素的宽度：$(obj).outerWidth(); (height + padding + border) 获取或设置元素的高度：$(obj).outerHeight(); (height + padding + border) 获取或设置元素的宽度：$(obj).outerWidth(true); (height + padding + border + margin) 获取或设置元素的高度：$(obj).outerHeight(true); (height + padding + border + margin) 某个元素的上边界到body最顶部的距离：obj.offset().top;（在元素的包含元素不含滚动条的情况下） 某个元素的左边界到body最左边的距离：obj.offset().left;（在元素的包含元素不含滚动条的情况下） 返回当前元素的上边界到它的包含元素的上边界的偏移量：obj.offset().top（在元素的包含元素含滚动条的情况下） 返回当前元素的左边界到它的包含元素的左边界的偏移量：obj.offset().left（在元素的包含元素含滚动条的情况下） Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"web/js/function.html":{"url":"web/js/function.html","title":"js常用函数","summary":"js常用函数","keywords":"","body":"js常用函数 1、split() 方法用于把一个字符串分割成字符串数组。 如： var str=\"how are you doing today?\" console.log(str.split(\" \")); //[\"how\", \"are\", \"you\", \"doing\", \"today?\"] console.log(str.split(\" \",3)); //[\"how\", \"are\", \"you\"] 2、join() 方法用于把数组中的所有元素放入一个字符串。如： var arr = [\"George\",\"John\",\"Thomas\"]; console.log(arr.join()); //\"George,John,Thomas\" console.log(arr.join(\".\")); //\"George.John.Thomas\" 3、concat() 方法用于连接两个或多个数组。如： var a = [1,2,3], b=[4,5,6] console.log(a.concat(4,5)); //[1, 2, 3, 4, 5] console.log(a.concat(b)); //[1, 2, 3, 4, 5, 6] 4、pop() 方法用于删除并返回数组的最后一个元素。如： var arr = [\"George\",\"John\",\"Thomas\"]; console.log(arr.pop()); //\"Thomas\" console.log(arr); //[\"George\", \"John\"] 5、push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。如： var arr = [\"George\",\"John\",\"Thomas\"]; console.log(arr.push(\"tom\")); //4 console.log(arr); //[\"George\", \"John\", \"Thomas\", \"tom\"] 6、reverse() 方法用于颠倒数组中元素的顺序。如： var arr = [\"George\",\"John\",\"Thomas\"]; console.log(arr.reverse()); //[\"tom\", \"Thomas\", \"John\", \"George\"] 7、shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。(如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。请注意，该方法不创建新数组，而是直接修改原有的 arrayObject)如： var arr = [\"George\",\"John\",\"Thomas\"]; console.log(arr.shift()); //\"tom\" 8、slice() 方法可从已有的数组中返回选定的元素。语法：arrayObject.slice(start,end) start 必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。 end 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 var arr = [\"George\",\"John\",\"Thomas\"]; console.log(arr.slice(1)); //[\"John\", \"George\"] console.log(arr.slice(0,2)); //[\"Thomas\", \"John\"] 9、sort() 方法用于对数组的元素进行排序。（对数组元素首字母或首数字排序）如： var arr=[\"George\",\"John\",\"Thomas\",\"James\",\"Adrew\",\"Martin\"]; console.log(arr.sort()); //[\"Adrew\", \"George\", \"James\", \"John\", \"Martin\", \"Thomas\"] 对数字进行排序需借助函数 var arr=[10,5,40,25,1000,1]; function sortNumber(a,b){ return a - b } console.log(arr.sort(sortNumber)); //[1, 5, 10, 25, 40, 1000] 10、splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。如： var arr=[\"George\",\"John\",\"Thomas\",\"James\",\"Adrew\",\"Martin\"]; //删除从 index 2 (\"Thomas\") 开始的三个元素，并添加一个新元素 (\"William\") 来替代被删除的元素 console.log(arr.splice(2,3,\"William\")); //[\"Thomas\", \"James\", \"Adrew\"] console.log(arr); //[\"George\", \"John\", \"William\", \"Martin\"] 11、toString() 方法可把数组转换为字符串，并返回结果。如： var arr=[\"George\",\"John\",\"Thomas\",\"James\",\"Adrew\",\"Martin\"]; console.log(arr.toString()); //\"George,John,Thomas,James,Adrew,Martin\" 12、toLocaleString() 把数组转换为本地字符串。如： var arr=[\"George\",\"John\",\"Thomas\",\"James\",\"Adrew\",\"Martin\"]; console.log(arr.toLocaleString()); //\"George,John,Thomas,James,Adrew,Martin\" 13、unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。（注：unshift() 方法无法在 Internet Explorer 中正确地工作！）如： var arr=[\"George\",\"John\",\"Thomas\"]; console.log(arr.unshift(\"William\")); //4 console.log(arr); //[\"William\", \"George\", \"John\", \"Thomas\"] 14、valueOf() 方法返回 Array 对象的原始值。如： var arr=[\"George\",\"John\",\"Thomas\"]; console.log(arr.valueOf()); //[\"George\",\"John\",\"Thomas\"] 15、js数据类型 字符串、数字、布尔、数组、对象、Null、Undefined JS Math 对象 具体的可查看：http://www.w3school.com.cn/jsref/jsref_obj_math.asp ,下面列举几个主要的 1、Math.abs(x) 方法可返回数的绝对值。如： document.write(Math.abs(7.25)) //7.25 document.write(Math.abs(-7.25)) //7.25 document.write(Math.abs(7.25-10)) //2.75 2、Math.ceil(x) 方法可对一个数进行上舍入。如： document.write(Math.ceil(0.60)) // 1 document.write(Math.ceil(5.1)) // 6 document.write(Math.ceil(-5.1)) // -5 document.write(Math.ceil(-5.9)) //-5 3、Math.floor(x) 方法可对一个数进行下舍入。如： document.write(Math.floor(0.60)) //0 document.write(Math.floor(0.40)) //0 document.write(Math.floor(5)) //5 document.write(Math.floor(-5.9)) //-6 4、Math.max(x,y) 方法可返回两个指定的数中带有较大的值的那个数。如： document.write(Math.max(5,7)) //7 document.write(Math.max(-3,5)) //5 document.write(Math.max(-3,-5)) //-3 5、Math.min(x,y) 方法可返回指定的数字中带有最低值的数字。如： document.write(Math.max(5,7)) //5 document.write(Math.max(-3,5)) //-3 document.write(Math.max(-3,-5)) //-5 6、Math.random() 方法可返回介于 0 ~ 1 之间的一个随机数。如： document.write(Math.random()) //0.17967150011099875 7、Math.round(x) 方法可把一个数字舍入为最接近的整数。如： document.write(Math.round(0.60)) //1 document.write(Math.round(0.50)) //1 document.write(Math.round(0.49)) //0 document.write(Math.round(-4.40)) //-4 document.write(Math.round(-4.60)) //-5 8、object.toSource() 方法返回表示对象源代码的字符串。如： function employee(name,job,born){ this.name=name; this.job=job; this.born=born; } var bill=new employee(\"Bill Gates\",\"Engineer\",1985); document.write(bill.toSource()); //({name:\"Bill Gates\", job:\"Engineer\", born:1985}) 9、valueOf() 方法可返回 Boolean 对象的原始值。如： 对象 返回值 Array 数组实例对象。 Boolean 布尔值。 Date 以毫秒数存储的时间值，从 UTC 1970 年 1 月 1 日午夜开始计算。 Function 函数本身。 Number 数字值。 Object 对象本身。这是默认设置。 String 字符串值。 // Array：返回数组对象本身 var array = [\"CodePlayer\", true, 12, -5]; document.writeln( array.valueOf() === array ); // true // Date：当前时间距1970年1月1日午夜的毫秒数 var date = new Date(2013, 7, 18, 23, 11, 59, 230); document.writeln( date.valueOf() ); // 1376838719230 // Number：返回数字值 var num = 15.26540; document.writeln( num.valueOf() ); // 15.2654 // 布尔：返回布尔值true或false var bool = true; document.writeln( bool.valueOf() === bool ); // true // new一个Boolean对象 var newBool = new Boolean(true); // valueOf()返回的是true，两者的值相等 document.writeln( newBool.valueOf() == newBool ); // true // 但是不全等，两者类型不相等，前者是boolean类型，后者是object类型 document.writeln( newBool.valueOf() === newBool ); // false // Function：返回函数本身 function foo(){ } document.writeln( foo.valueOf() === foo ); // true var foo2 = new Function(\"x\", \"y\", \"return x + y;\"); document.writeln( foo2.valueOf() === foo2 ); // true // Object：返回对象本身 var obj = {name: \"张三\", age: 18}; document.writeln( obj.valueOf() === obj ); // true // String：返回字符串值 var str = \"http://www.365mini.com\"; document.writeln( str.valueOf() === str ); // true // new一个字符串对象 var str2 = new String(\"http://www.365mini.com\"); // 两者的值相等，但不全等，因为类型不同，前者为string类型，后者为object类型 document.writeln( str2.valueOf() === str2 ); // false Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"web/js/ajax.html":{"url":"web/js/ajax.html","title":"ajax写法","summary":"ajax写法","keywords":"","body":"ajax写法 $(function(){ $.ajax({ url: '/path/to/file', type: 'get or post', dataType: 'default: Intelligent Guess (Other values: xml, json, jsonp, script, or html)', data: {param1:'value1', param2:'value2'}, jsonp: \"jsoncallback\", //ajax跨域写法 async: true, //默认值: true。默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。 processData: false, // 告诉jQuery不要去处理发送的数据 contentType: false, // 告诉jQuery不要去设置Content-Type请求头 success: function (data){ /*当请求之后调用。传入返回后的数据，以及包含成功代码的字符串。*/ }, dataFilter: function(){ /*在请求成功之后调用。传入返回的数据以及 \"dataType\" 参数的值。并且必须返回新的数据（可能是处理过的）传递给 success 回调函数。*/ }, error: function(){ /*在请求出错时调用*/ }, beforeSend: function(){ /*在发送请求之前调用*/ }, complete: function(){ /*当请求完成之后调用这个函数*/ } }); }) Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"web/plugin/":{"url":"web/plugin/","title":"常用插件","summary":"常用插件","keywords":"","body":"常用插件 项目开发中用到的一些插件汇总 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"web/plugin/model.html":{"url":"web/plugin/model.html","title":"常用弹层插件","summary":"常用弹层插件","keywords":"","body":"常用弹层插件 1、layer 弹出层 api文档地址：https://www.layui.com/doc/modules/layer.html 实例：（注：手机，PC端都比较好用） var layerNo = layer.open({ type: 1, shade: false, title: false, //不显示标题 content: $('.popup-box'), //捕获的元素 area: ['200px', '100px'] }); layer.close(layerNo); //关闭当前弹层 layer.closeAll(); //关闭当前所有的弹层 2、fancyBox 弹出层 api文档：http://fancyapps.com/fancybox/#docs http://simplemodal.plasm.it/ 中文文档：http://www.weste.net/2013/4-22/90629.html 实例：（注：根本网站需求具体运用还是查看API，主要运用在PC端） var content=\"sdfs\" function showDiv(){ var content=\"&lt;div class='content_box'&gt;\"+ \"&lt;div class='content'&gt;fancybox弹出内容&lt;/div&gt;\"+ \"&lt;a class='btn' href='javascript:$.fancybox.close();'&gt;确定&lt;/a&gt;\"+ \"&lt;/div&gt;\" return packageFancybox(content); } function packageFancybox(template){ return $.fancybox(template,{ padding:20, margin:10, width:200, height:40, minWidth:200, autoSize:false, //默认是:true,自适应，变为:false后设置的宽和高才有效。 closeBtn:false, //默认是:true,变为:false后close键隐藏。 closeClick:true, //默认是:false,变为:true后点击弹框内的内容弹框也会消失。 modal:true //默认是:false,变为:true后点击外面透明黑背景弹框不会消失。 }) } showDiv(); 3、jquery.simplemodal.min.js 插件弹出层 api文档地址：http://blog.sina.com.cn/s/blog_6a1fb8420100psj0.html 实例： var _deal = $(\"#register-notice\").modal({width: 800, height: 600,close:false}); _deal.close(); //关闭弹出层 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"web/plugin/plugins.html":{"url":"web/plugin/plugins.html","title":"常用效果插件","summary":"常用效果插件","keywords":"","body":"常用效果插件 1、select 选择下拉效果：https://select2.github.io/examples.html 2、 jQuery全屏滚动插件fullPage.js ：http://www.jq22.com/jquery-info1124 3、 Swiper演示 ：http://www.swiper.com.cn/demo/index.html 4、superslide2插件：http://www.superslide2.com/demo.html 5、ECharts图表数据插件：http://echarts.baidu.com/index.html 6、Highcharts图表数据插件：http://www.hcharts.cn/index.php Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"hexo/hexo_music.html":{"url":"hexo/hexo_music.html","title":"Hexo博客yilia主题添加背景音乐","summary":"Hexo博客yilia主题添加背景音乐-（网易云音乐）","keywords":"","body":"Hexo博客yilia主题添加背景音乐-（网易云音乐） 博主博客地址 1、打开网易云音乐首页，复制选择的背景音乐分享外链 网易云音乐 2、引入播放器代码     在themes/yilia/layout/_partial/left-col.ejs文件nav标签中添加代码 注：放在和之内     笔者添加了一些判断和表达式 &auto=&height=32\"> 3、在yilia主题配置文件中添加属性 # 网易云音乐插件 music: enable: true #id: 1332647902 # 网易云分享的ID autoplay: true # 是否开启自动播放 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:33 "},"hexo/hexo_live2d.html":{"url":"hexo/hexo_live2d.html","title":"Hexo博客添加helper-live2d动态模型插件","summary":"Hexo博客添加helper-live2d动态模型插件","keywords":"","body":"Hexo博客添加helper-live2d动态模型插件 Tips:前导必备 博主博客地址 博主使用的是yilia主题 插件的github地址hexo-helper-live2d live2d模型仓库 必须有Node环境 ➡️ Linux下安装node和npm 1、安装模块     在hexo根目录执行命令 # npm install --save hexo-helper-live2d 2、下载模型     作者各种模型包展示 ➡️ hexo live2d插件 2.0 ! live2d模型仓库 live2d-widget-model-chitose live2d-widget-model-epsilon2_1 live2d-widget-model-gf live2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru) live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru) live2d-widget-model-haruto live2d-widget-model-hibiki live2d-widget-model-hijiki live2d-widget-model-izumi live2d-widget-model-koharu live2d-widget-model-miku live2d-widget-model-ni-j live2d-widget-model-nico live2d-widget-model-nietzsche live2d-widget-model-nipsilon live2d-widget-model-nito live2d-widget-model-shizuku live2d-widget-model-tororo live2d-widget-model-tsumiki live2d-widget-model-unitychan live2d-widget-model-wanko live2d-widget-model-z16 使用npm install {packagename}安装模型 ---笔者使用的模型 # npm install live2d-widget-model-hibiki 3、详细配置 在Hexo的 _config.yml 文件或主题的 _config.yml 文件中添加配置. 参阅 live2d-widget.js API 博主配置文件示例 # Live2D ## https://github.com/EYHN/hexo-helper-live2d ## https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init live2d: enable: true #enable: false scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 debug: false # 调试, 是否在控制台输出日志 model: use: live2d-widget-model-hibiki # use: live2d-widget-model-wanko # npm-module package name # use: wanko # 博客根目录/live2d_models/ 下的目录名 # use: ./wives/wanko # 相对于博客根目录的路径 # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url display: position: right width: 145 height: 315 mobile: show: true # 是否在移动设备上显示 scale: 0.5 # 移动设备上的缩放 react: opacityDefault: 0.7 opacityOnHover: 0.8 4、作者寄语 Everything is ok. But you have to do by yourself. Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:33 "},"hexo/hexo_pv.html":{"url":"hexo/hexo_pv.html","title":"Hexo博客添加访问量统计","summary":"Hexo博客添加访问量统计","keywords":"","body":"Hexo博客添加访问量统计 Tips:前导必备 博主博客地址 博主使用的是yilia主题 访问量统计使用不蒜子 1、配置是否开启不蒜子访问量统计功能     在themes/yilia/_config.yml添加属性 # 是否开启访问量统计功能(不蒜子) busuanzi: enable: true 2、引入不蒜子并添加站点访问量     在themes/yilia/layout/_partial/footer.ejs末尾添加如下代码 本站总访问量次 | 本站访客数人 3、添加文章访问量     在themes/yilia/layout/_partial/post/date.ejs开头添加如下代码 \"> 阅读数：次 重启即可查看效果 4、作者寄语 Everything is ok. But you have to do by yourself. Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:33 "},"hexo/hexo_github.html":{"url":"hexo/hexo_github.html","title":"使用Hexo+GitHub搭建免费个人博客","summary":"使用Hexo+GitHub搭建免费个人博客","keywords":"","body":"使用Hexo+GitHub搭建免费个人博客 博主GitHub博客地址:https://joeybling.github.io/ 联系QQ:2434387555 此博客的所有操作均在Linux上完成 本文所使用的环境：Centos 6.5Final@64Bit、NodeJs@v8.11.1、hexo@3.2.2 1、前言 使用github-pages服务搭建博客的好处有： 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台； 等等； 1.1、准备工作 有一个github账号，没有的话去注册一个 安装了node.js、npm，并了解相关基础知识 传送门 ➡️ Linux上安装node和npm 2、搭建GitHub博客 2.1、创建仓库 建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io了，是不是很方便？ 几个注意的地方： 注册的邮箱一定要验证，否则不会成功； 仓库名字必须是：username.github.io，其中username是你的用户名； 仓库创建成功不会立即生效，需要过一段时间，大概3-10分钟左右 仓库创建成功后需要开启pages服务 settings ➡️ GitHub Pages ➡️ 选择分支并开启服务 2.2、绑定域名(看自己选择是否使用) 绑定域名分2种情况：带www和不带www的。 域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下你的用户名.github.io的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向你的用户名.github.io，这样可以保证无论是否添加www都可以访问，如下： 然后到你的github项目根目录新建一个名为CNAME的文件（无后缀），里面填写你的域名，加不加www看你自己喜好，因为经测试： 如果你填写的是没有www的，比如 mygit.me，那么无论是访问 http://www.mygit.me 还是 http://mygit.me ，都会自动跳转到 http://mygit.me 如果你填写的是带www的，比如 www.mygit.me ，那么无论是访问 http://www.mygit.me 还是 http://mygit.me ，都会自动跳转到 http://www.mygit.me 如果你填写的是其它子域名，比如 abc.mygit.me，那么访问 http://abc.mygit.me 没问题，但是访问 http://mygit.me ，不会自动跳转到 http://abc.mygit.me 另外说一句，在你绑定了新域名之后，原来的你的用户名.github.io并没有失效，而是会自动跳转到你的新域名。 3、使用hexo写博客 3.1、安装hexo # npm install -g hexo-cli # 做个软链接 # cd /usr/local/bin # 这是是你的Node解压安装的路径 # ln -s /opt/node-v8.11.1-linux-x64/bin/hexo 3.2、初始化 在某个地方新建一个名为hexo的文件夹 # mkdir -p /workspaces/hexo # cd /workspaces/hexo/ # hexo init 目录结构如下图: # hexo g # 生成 # hexo s # 启动服务 打开浏览器访问 http://IP:4000 即可看到内容 如下: 3.3、修改主题 有哪些好看的 Hexo 主题？ 传送门 ➡️ https://www.zhihu.com/question/24422335 个人比较喜欢的 ➡️ https://github.com/litten/hexo-theme-yilia # cd /workspaces/hexo/themes/ # yum install -y wget # wget https://codeload.github.com/litten/hexo-theme-yilia/zip/master # yum install -y unzip # unzip master # mv hexo-theme-yilia-master/ yilia # ll 下载后的主题都在这里： 修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。 如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。 # yum install -y vim # 修改_config.yml中的theme: landscape改为theme: yilia # vim /workspaces/hexo/_config.yml # 重新生成 # hexo g # hexo s 3.4、上传到GitHub 上传public 文件夹里所有的文件 ，可以拷贝出来使用git上传到GitHub 3.5、常用hexo命令 hexo new \"postName\" 新建文章 hexo new page \"pageName\" 新建页面 hexo generate 生成静态页面至public目录 hexo server 开启预览访问端口（默认端口4000，'ctrl + c'关闭server） hexo deploy 部署到GitHub hexo help 查看帮助 hexo version 查看Hexo的版本 缩写： hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 组合命令： hexo s -g 生成并本地预览 hexo d -g 生成并上传 3.6、_config.yml文件配置 需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。 3.7、写博客 定位到我们的hexo根目录，执行命令： # hexo new 'my-first-blog' hexo会帮我们在_posts下生成相关md文件： 我们只需要打开这个文件就可以开始写博客了，默认生成如下内容： 当然你也可以直接自己新建md文件，用这个命令的好处是帮我们自动生成了时间。 一般完整格式如下： --- title: postName #文章页面上的显示名称，一般是中文 date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改 categories: 默认分类 #分类 tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格 description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面 --- 以下是正文..... 推荐一个在线写博客工具 ➡️ http://pandao.github.io/editor.md/ Tips:如何让博文列表不显示全部内容 默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？ 答案是在合适的位置加上 即可，例如： # 前言 使用github pages服务搭建博客的好处有： 1. 全是静态文件，访问速度快； 2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 5. 博客内容可以轻松打包、转移、发布到其它平台； 6. 等等； 最终效果： Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:33 "},"hexo/article_set_top.html":{"url":"hexo/article_set_top.html","title":"新增Hexo博客文章置顶功能","summary":"新增Hexo博客文章置顶功能","keywords":"","body":"新增Hexo博客文章置顶功能 博主博客地址 修改Hexo文件夹下的node_modules/hexo-generator-index/lib/generator.js 需要添加的代码： posts.data = posts.data.sort(function(a, b) { if(a.top && b.top) { if(a.top == b.top) return b.date - a.date; else return b.top - a.top; } else if(a.top && !b.top) { return -1; } else if(!a.top && b.top) { return 1; } else return b.date - a.date; }); 以下是最终的generator.js内容： 'use strict'; var pagination = require('hexo-pagination'); module.exports = function(locals) { var config = this.config; var posts = locals.posts.sort(config.index_generator.order_by); posts.data = posts.data.sort(function(a, b) { if(a.top && b.top) { if(a.top == b.top) return b.date - a.date; else return b.top - a.top; } else if(a.top && !b.top) { return -1; } else if(!a.top && b.top) { return 1; } else return b.date - a.date; }); var paginationDir = config.pagination_dir || 'page'; var path = config.index_generator.path || ''; return pagination(path, posts, { perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: { __index: true } }); }; 如何使用：在需要置顶的文章添加top属性即可，排序从小到大 博客效果： Tips:常用hexo命令 # hexo n == hexo new # hexo g == 生成 # hexo s == 启动服务 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:33 "},"notes/git_branch.html":{"url":"notes/git_branch.html","title":"Git分支的创建、删除、切换","summary":"Git分支的创建、删除、切换","keywords":"","body":"Git分支的创建、删除、切换 1、本地创建新分支并切换到新分支 # git checkout -b 分支名 2、提交分支到远程仓库 # git push origin 分支名 3、切换分支 # git checkout 分支名 4、删除远程分支 # git push origin --delete 分支名 5、删除本地分支 # git branch -D 分支名 Tips：其他分支命令 查看当前分支 git branch 查看所属分支 git branch -a Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"notes/git_history.html":{"url":"notes/git_history.html","title":"Git彻底删除历史提交记录的方法","summary":"Git彻底删除历史提交记录的方法","keywords":"","body":"Git彻底删除历史提交记录的方法 1、查看Git提交记录 # git log 2、找到需要回滚到的提交点，复制它的hash值 # git reset --hard 你复制的hash值 3、将当前指向的head推到git # git push --force Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"notes/gitbook.html":{"url":"notes/gitbook.html","title":"GitBook的安装、卸载、常见问题","summary":"GitBook的安装、卸载、常见问题","keywords":"","body":"GitBook的安装、卸载、常见问题 Tips:博主使用的版本 博主博客地址 Node v8.11.2 npm v6.9.0 gitbook v3.2.3 服务器 CentOS6.5 官方GitHub:https://github.com/GitbookIO/gitbook-cli GitBook相关配置及优化 一、卸载GitBook(没有安装的跳过此步骤) Tips:前导摘要：记得有一次不小心卸载了一个东西，后面执行gitbook init报错：Cannot find module 'internal/util/types 找到C:\\Users\\{User}\\.gitbook 找到并删除此文件夹 删除后执行命令 # npm uninstall -g gitbook # npm uninstall -g gitbook-cli --- 清除npm缓存 # npm cache clean --force 二、安装GitBook 需要node环境 ➡️ Linux或Win下安装node和npm 需要Git环境 ➡️ https://www.jianshu.com/p/f2da5e76a588 # npm install gitbook -g # npm install -g gitbook-cli --- 如果没有安装gitbook,此命令会默认同时安装 GitBook # gitbook -V --- 列出本地所有的gitbook版本 # gitbook ls Tips:GitBook常用命令 gitbook -V 查看版本号 gitbook ls 列出本地所有的gitbook版本 gitbook init 初始化 gitbook install 安装插件 gitbook serve 预览 gitbook build 生成 gitbook build --gitbook=2.6.7 生成时指定gitbook的版本, 本地没有会先下载 gitbook uninstall 2.6.7 卸载指定版本号的gitbook gitbook fetch [version] 获取[版本]下载并安装 gitbook --help 显示gitbook-cli帮助文档 gitbook help 列出 gitbook 所有的命令 gitbook ls-remote 列出NPM上的可用版本： 三、GitBook插件 五、作者寄语 Everything is ok. But you have to do by yourself. Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"notes/gitbook_config.html":{"url":"notes/gitbook_config.html","title":"GitBook相关配置及优化","summary":"GitBook相关配置及优化","keywords":"","body":"GitBook相关配置及优化 1、GitBook配置说明 1.1、目录结构 ├── book.json ├── README.md ├── SUMMARY.md ├── chapter-1/ | ├── README.md | ├── something.md ├── chapter-2/ | ├── README.md 1.2、GitBook 特殊文件的功能： 文件名 描述 book.json 配置数据 (optional) README.md 电子书的前言或简介 (required) SUMMARY.md 电子书目录 (optional) GLOSSARY.md 词汇/注释术语列表 (optional) 1.3、book.json的配置说明 变量 描述 root 包含所有图书文件的根文件夹的路径，除了 book.json structure 指定自述文件，摘要，词汇表等的路径 title 您的书名，默认值是从 README 中提取出来的。在 GitBook.com 上，这个字段是预填的。 description 您的书籍的描述，默认值是从 README 中提取出来的。在 GitBook.com 上，这个字段是预填的。 author 作者名。在GitBook.com上，这个字段是预填的。 isbn 国际标准书号 ISBN language 本书的语言类型 —— ISO code 。默认值是 en direction 文本阅读顺序。可以是 rtl （从右向左）或 ltr （从左向右），默认值依赖于 language 的值。 gitbook 应该使用的GitBook版本，并接受类似于 >=3.0.0 的条件。 links 在左侧导航栏添加链接信息 plugins 要加载的插件列表(官网插件列表) pluginsConfig 插件的配置 1.4、Gitbook 默认带有 5 个插件： highlight - 语法高亮插件、search - 搜索插件、sharing - 分享插件、font-settings - 字体设置插件、livereload - 热加载插件 1.5、去除自带插件 可以在插件名称前面加 - \"plugins\": [ \"-search\" ] Tips：添加插件后要进行安装 gitbook install 1.6、设置PDF输出格式 变量 描述 pdf.pageNumbers 是否添加页码，默认是true pdf.fontSize 字体大小，默认是12 pdf.fontFamily 字体，默认字体是Arial pdf.paperSize Paper size, options are a0,a1,a2,a3,a4,a5,a6,b0,b1,b2,b3,b4,b5,b6,legal,letter(default is a4) pdf.margin.top Top margin (default is 56) pdf.margin.bottom Bottom margin (default is 56) pdf.margin.right Right margin (default is 62) pdf.margin.left Left margin (default is 62) 2、GitBook生成电子书 需要有calibre-ebook环境 ➡️ Linux下安装calibre-ebook GitBook生成pdf出现中文不显示或乱码 --- 生成PDF文件 # gitbook pdf ./ ./mybook.pdf --- 生成ePub文件 # gitbook epub ./ ./mybook.epub --- 生成Mobi文件 # gitbook mobi ./ ./mybook.mobi 3、使用gitbook-convert 说明：把docx、xml、html、odt文档转成GitBook 官网地址：https://github.com/GitbookIO/gitbook-convert # npm install gitbook-convert -g --- 如果需要做软链 # ln -s /usr/local/node-v8.11.2-linux-x64/bin/gitbook-convert /usr/local/bin/gitbook-convert --- 如何使用 # gitbook-convert [options] [export-directory] 4、GitBook插件列表 mygitalk 基于gitalk的评论插件 ➡️ https://github.com/snowdreams1006/gitbook-plugin-mygitalk theme-default GitBook的默认主题 ➡️ https://github.com/GitbookIO/theme-default autotheme 自动换肤插件 ➡️ https://github.com/willin/gitbook-plugin-autotheme sharing 默认的分享插件 ➡️ https://github.com/GitbookIO/plugin-sharing fontsettings 默认的字体、字号、颜色设置插件 ➡️ https://github.com/GitbookIO/plugin-fontsettings highlight 默认的代码高亮插件，通常会使用 prism 来替换 ➡️ https://github.com/GitbookIO/plugin-highlight search 默认搜索插件 ➡️ https://github.com/GitbookIO/plugin-search search-plus 支持中文搜索插件 ➡️ https://github.com/lwdgit/gitbook-plugin-search-plus prism 基于 Prism 的代码高亮 ➡️ https://github.com/gaearon/gitbook-plugin-prism favicon 更改网站的 favicon.ico ➡️ https://github.com/menduo/gitbook-plugin-favicon github 在右上角显示 github 仓库的图标链接 ➡️ https://github.com/GitbookIO/plugin-github github-buttons 显示 github 仓库的star和fork按钮 ➡️ https://github.com/azu/gitbook-plugin-github-buttons splitter 在左侧目录和右侧内容之间添加一个可以拖拽的栏，用来调整两边的宽度 ➡️ https://github.com/yoshidax/gitbook-plugin-splitter copy-code-button 为代码块添加复制的按钮 ➡️ https://github.com/WebEngage/gitbook-plugin-copy-code-button tbfed-pagefooter 自定义页脚，显示版权和最后修订时间 ➡️ https://github.com/zhj3618/gitbook-plugin-tbfed-pagefooter expandable-chapters 收起或展开章节目录中的父节点 ➡️ https://github.com/DomainDrivenArchitecture/gitbook-plugin-expandable-chapters expandable-chapters-small 比较好的折叠侧边栏 ➡️ https://github.com/lookdczar/gitbook-plugin-expandable-chapters-small-auto book-summary-scroll-position-saver 自动保存左侧目录区域导航条的位置 ➡️ https://github.com/yoshidax/gitbook-plugin-book-summary-scroll-position-saver ga 添加 Google 统计代码 ➡️ https://github.com/GitbookIO/plugin-ga sitemap 生成站点地图 ➡️ https://github.com/GitbookIO/plugin-sitemap baidu 使用百度统计 ➡️ https://github.com/poppinlp/gitbook-plugin-baidu Donate Gitbook 捐赠打赏插件 ➡️ https://github.com/willin/gitbook-plugin-donate anchors 标题带有 github 样式的锚点 ➡️ https://github.com/rlmv/gitbook-plugin-anchors anchor-navigation-ex 插件锚导航-EX ➡️ https://github.com/zq99299/gitbook-plugin-anchor-navigation-ex theme-api 编写 API 文档 ➡️ https://github.com/GitbookIO/theme-api katex 使用KaTex进行数学排版 ➡️ https://github.com/GitbookIO/plugin-katex editlink 内容顶部显示编辑本页链接 ➡️ https://github.com/zhaoda/gitbook-plugin-editlink ad 在每个页面顶部和底部添加广告或任何自定义内容 ➡️ https://github.com/zhaoda/gitbook-plugin-ad image-captions 抓取内容中图片的alt或title属性，在图片下面显示标题 ➡️ https://github.com/todvora/gitbook-plugin-image-captions chart 使用 C3.js 图表 ➡️ https://github.com/csbun/gitbook-plugin-chart styles-sass 使用 SASS 替换 CSS ➡️ https://github.com/GitbookIO/plugin-styles-sass styles-less 使用 LESS 替换 CSS ➡️ https://github.com/GitbookIO/plugin-styles-less disqus 添加 disqus 评论插件 ➡️ https://github.com/GitbookIO/plugin-disqus latex-codecogs 使用数学方程式 ➡️ https://github.com/GitbookIO/plugin-latex-codecogs mermaid 使用流程图 ➡️ https://github.com/JozoVilcek/gitbook-plugin-mermaid atoc 插入 TOC 目录 ➡️ https://github.com/willin/gitbook-plugin-atoc ace 插入代码高亮编辑器 ➡️ https://github.com/ymcatar/gitbook-plugin-ace sectionx 分离各个段落，并提供一个展开收起的按钮 ➡️ https://github.com/ymcatar/gitbook-plugin-sectionx mcqx 交互式多选插件 ➡️ https://github.com/ymcatar/gitbook-plugin-mcqx include-codeblock 通过引用文件插入代码 ➡️ https://github.com/azu/gitbook-plugin-include-codeblock fbqx 使用填空题 ➡️ https://github.com/Erwin-Chan/gitbook-plugin-fbqx spoiler 隐藏答案，当鼠标划过时才显示 ➡️ https://github.com/ymcatar/gitbook-plugin-spoiler anchor-navigation 锚点导航 ➡️ https://github.com/yaneryou/gitbook-plugin-anchor-navigation youtubex 插入 YouTube 视频 ➡️ https://github.com/ymcatar/gitbook-plugin-youtubex redirect 重定向页面跳转 ➡️ https://github.com/ketan/gitbook-plugin-redirect duoshuo 使用多说评论 ➡️ https://github.com/codepiano/gitbook-plugin-duoshuo jsfiddle 插入 JSFiddle 组件 ➡️ https://github.com/Mavrin/gitbook-plugin-jsfiddle jsbin 插入 JSBin 组件 ➡️ https://github.com/jcouyang/gitbook-plugin-jsbin Advanced Emoji 支持emoji表情 ➡️ https://github.com/codeclou/gitbook-plugin-advanced-emoji Puml 使用 PlantUML 展示 uml 图 ➡️ https://github.com/GitbookIO/plugin-puml Graph 使用 function-plot 绘制数学函数图 ➡️ https://github.com/cjam/gitbook-plugin-graph Todo 添加 Todo 功能 ➡️ https://github.com/ly-tools/gitbook-plugin-todo include-csv 展示 csv 文件内容 ➡️ https://github.com/TakuroFukamizu/gitbook-plugin-include-csv musicxml 支持 musicxml 格式的乐谱渲染 ➡️ https://github.com/ymcatar/gitbook-plugin-musicxml versions-select 添加版本选择的下拉菜单，针对文档有多个版本的情况 ➡️ https://github.com/prescottprue/gitbook-plugin-versions-select rss 添加 rss 订阅功能 ➡️ https://github.com/denysdovhan/gitbook-plugin-rss multipart 将书籍分成几个部分 ➡️ https://github.com/citizenmatt/gitbook-plugin-multipart url-embed 嵌入动态内容 ➡️ https://github.com/basilvetas/gitbook-plugin-url-embed 5、博主示例book.json配置 { \"gitbook\": \"3.x.x\", \"plugins\": [\"favicon\", \"yahei\", \"github\", \"autotheme\", \"-lunr\", \"-search\", \"search-plus\", \"prism\", \"-highlight\", \"github-buttons\", \"splitter\", \"-sharing\", \"sharing-plus\", \"tbfed-pagefooter\", \"expandable-chapters-small\", \"book-summary-scroll-position-saver\", \"ga\", \"baidu\", \"donate\", \"anchors\", \"anchor-navigation-ex\", \"sitemap-general\", \"copy-code-button\", \"mygitalk\", \"multipart\" ], \"pluginsConfig\": { \"theme-default\": { \"showLevel\": true }, \"fontSettings\": { \"family\": \"serif\", \"size\": 2 }, \"github\": { \"url\": \"https://github.com/JoeyBling\" }, \"autotheme\": { \"white\": [9, 10, 11, 12, 13, 14, 15, 16, 17], \"sepia\": [6, 7, 8, 18, 19], \"night\": [20, 21, 22, 23, 0, 1, 2, 3, 4, 5] }, \"prism\": { \"css\": [ \"prismjs/themes/prism-tomorrow.css\" ] }, \"github-buttons\": { \"buttons\": [{ \"user\": \"JoeyBling\", \"repo\": \"myBook\", \"type\": \"star\", \"size\": \"small\", \"count\": true }] }, \"sharing\": { \"douban\": false, \"facebook\": false, \"google\": true, \"hatenaBookmark\": false, \"instapaper\": false, \"line\": true, \"linkedin\": true, \"messenger\": false, \"pocket\": false, \"qq\": false, \"qzone\": true, \"stumbleupon\": false, \"twitter\": false, \"viber\": false, \"vk\": false, \"weibo\": true, \"whatsapp\": false, \"all\": [ \"facebook\", \"google\", \"twitter\", \"weibo\", \"instapaper\", \"linkedin\", \"pocket\", \"stumbleupon\" ] }, \"tbfed-pagefooter\": { \"copyright\": \"Copyright &copy 試毅-思伟 2019\", \"modify_label\": \"修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"ga\": { \"token\": \"UA-142790104-1\" }, \"baidu\": { \"token\": \"f1f256f18b7899e11647d6ec1f3ded2f\" }, \"donate\": { \"wechat\": \"/assets/weixin.png\", \"alipay\": \"/assets/alipay.jpeg\", \"title\": \"\", \"button\": \"赏\", \"alipayText\": \"支付宝打赏\", \"wechatText\": \"微信打赏\" }, \"anchor-navigation-ex\": { \"showLevel\": true, \"associatedWithSummary\": false, \"printLog\": false, \"multipleH1\": true, \"mode\": \"float\", \"showGoTop\": true, \"float\": { \"floatIcon\": \"fa fa-navicon\", \"showLevelIcon\": false, \"level1Icon\": \"fa fa-hand-o-right\", \"level2Icon\": \"fa fa-hand-o-right\", \"level3Icon\": \"fa fa-hand-o-right\" }, \"pageTop\": { \"showLevelIcon\": false, \"level1Icon\": \"fa fa-hand-o-right\", \"level2Icon\": \"fa fa-hand-o-right\", \"level3Icon\": \"fa fa-hand-o-right\" } }, \"sitemap-general\": { \"prefix\": \"https://zhousiwei.gitee.io/myBook/\" }, \"favicon\": { \"shortcut\": \"/assets/images/favicon.ico\", \"bookmark\": \"/assets/images/favicon.ico\", \"appleTouch\": \"/assets/images/apple-touch-icon.png\", \"appleTouchMore\": { \"120x120\": \"/assets/images/apple-touch-icon-120x120.png\", \"180x180\": \"/assets/images/apple-touch-icon-180x180.png\" } }, \"mygitalk\": { \"clientID\": \"608e351b48e4d0a3a528\", \"clientSecret\": \"***加密***\", \"repo\": \"myBook\", \"owner\": \"JoeyBling\", \"admin\": [\"JoeyBling\"], \"distractionFreeMode\": false } }, \"pdf\": { \"pageNumbers\": true, \"fontFamily\": \"Arial\", \"fontSize\": 12, \"paperSize\": \"a4\", \"margin\": { \"right\": 62, \"left\": 62, \"top\": 56, \"bottom\": 56 } }, \"title\": \"試毅-思伟_开源项目\", \"description\": \"試毅-思伟_开源项目\", \"author\": \"試毅-思伟\", \"language\": \"zh-hans\", \"root\": \".\", \"structure\": { \"readme\": \"introduction.md\" }, \"links\": { \"sidebar\": { \"GitHub\": \"https://github.com/JoeyBling\", \"个人博客\": \"https://zhousiwei.gitee.io\" } } } Tips：添加插件后要进行安装 gitbook install Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"notes/idea_jrebel.html":{"url":"notes/idea_jrebel.html","title":"IDEA+JRebel全自动热部署","summary":"IDEA+JRebel全自动热部署","keywords":"","body":"IDEA+JRebel全自动热部署 链接：https://pan.baidu.com/s/1ZE5cv1vhFQhdaj91dFD-GA 密码：b2k8 下载后解压 1、打开IDEA离线安装插件，选择刚刚下载的ZIP就行了 2、激活JRebel 装完以后打开 IDEA ➡️ Help ➡️ JRebel ➡️ Activation 运行激活程序 地址填写 http://127.0.0.1:8888/Zephyr 邮箱随便填 3、使用及自动部署 依次打开 View ➡️ Tool Windows ➡️ JRebel 这时候已经实现热部署了,不过需要每次修改源码后手动执行UPDATE操作,我们可以结合Idea自身的Debug Hot swap功能,在运行和调试配置中,配置自动执行UPDATE操作 4、勾选自动编译功能 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"notes/idea_lombok.html":{"url":"notes/idea_lombok.html","title":"IDEA安装lombok及使用详解","summary":"IDEA安装lombok及使用详解","keywords":"","body":"IDEA安装lombok及使用详解 项目中经常使用bean，entity等类，绝大部分数据类类中都需要get、set、toString、equals和hashCode方法，虽然eclipse和idea开发环境下都有自 动生成的快捷方式，但自动生成这些代码后，如果bean中的属性一旦有修改、删除或增加时，需要重新生成或删除get/set等方法，给代码维护增加负担。而使用了lombok则不一样，使用了lombok的注解 (@Setter,@Getter,@ToString,@RequiredArgsConstructor,@EqualsAndHashCode或@Data)之后，就不需要编写或生成get/set等方法，很大程度上减少了代码量，而且减少了代码维护的负担。故强烈建议项目中使用lombok，去掉bean中get、set、toString、equals和hashCode等方法的代码。 1、安装lombok插件 2、添加lombok的maven的pom.xml依赖： org.projectlombok lombok 1.16.10 3、示例代码Student.java package com.lombok.demo; import lombok.EqualsAndHashCode; import lombok.Getter; import lombok.Setter; import lombok.ToString; /** * Created by zhousiwei on 2017/2/8 */ @Data public class Student { private String name; private int age; private String male; private String studentNo; } Tips:@Data注解的作用相当于@Getter,@Setter,@RequiredArgsConstructor,@ToString,@EqualsAndHashCode的合集。 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"notes/idea_norm.html":{"url":"notes/idea_norm.html","title":"IDEA设置后端代码开发规范","summary":"IDEA设置后端代码开发规范","keywords":"","body":"IDEA设置后端代码开发规范 1、IDEA 配置svn 提交svn报错： 1.1、下载：https://www.visualsvn.com/downloads/ 1.2、修改IDEA配置指向的路径： 2、IDEA 设置 Tab 键为 4 个空格 Scheme 选择 Project ,在下面把取消勾选 Use tab character 3、IDEA 设置编码格式为 UTF-8 4、IDEA 设置换行符为 Unix 编码格式 5、IDEA 设置类注释模板 /** * * @author Created by 思伟 on ${DATE} */ Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"notes/idea_tomcat.html":{"url":"notes/idea_tomcat.html","title":"解决Tomcat在IDEA控制台中文乱码的问题","summary":"解决Tomcat在IDEA控制台中文乱码的问题","keywords":"","body":"解决Tomcat在IDEA控制台中文乱码的问题 在idea的安装目录下的bin/idea.exe.vmoptions文件和idea64.exe.vmoptions文件的末尾另起一行添加 -Dfile.encoding=UTF-8 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"notes/mysql_config.html":{"url":"notes/mysql_config.html","title":"玩转MySQL优化命令","summary":"玩转MySQL优化命令","keywords":"","body":"玩转MySQL优化命令 1、MySQL更改为只能本地登录 # use mysql; # select user,host,Password from user where user='root'; # delete from user where user='root' and host='%'; 2、MySQL授予外网登陆权限 grant all privileges on *.* to 授予外网登陆的用户名@'%' identified by '密码' WITH GRANT OPTION; # grant all privileges on *.* to root@'%' identified by 'root' WITH GRANT OPTION; # flush privileges; 3、更改MySQL的存储目录 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"notes/bitcomet.html":{"url":"notes/bitcomet.html","title":"BitComet服务器列表","summary":"BitComet服务器列表","keywords":"","body":"BitComet服务器列表 udp://mgtracker.org:2710/announce http://share.camoe.cn:8080/announce udp://11.rarbg.me:80/announce http://tracker.tfile.me/announce http://open.acgtracker.com:1096/announce http://mgtracker.org:2710/announce udp://tracker.ex.ua:80/announce http://tracker.longwangbt.com:2710/announce udp://tracker.openbittorrent.com:80/announce http://tracker.publicbt.com/announce http://tracker.prq.to/announce udp://9.rarbg.me:2710/announce http://tracker1.wasabii.com.tw:6969/anno http://tracker2.wasabii.com.tw:6969/announce udp://explodie.org:6969/announce udp://shadowshq.eddie4.nl:6969/announce udp://shadowshq.yi.org:6969/announce udp://eddie4.nl:6969/announce udp://tracker.publicbt.com:80/announce udp://tracker.istole.it:80/announce http://trackers.ibzu.me/announce.php http://tracker1.torrentino.com/announce http://tracker2.torrentino.com/announce http://tracker3.torrentino.com/announce http://bt.careland.com.cn:6969/announce http://bt2.careland.com.cn:6969/announce http://bt3.careland.com.cn:6969/announce http://94.228.192.98/announce http://121.14.98.151:9090/announce http://henbt.com:2710/announce http://server1.9sheng.cn:6969/announce http://anisaishuu.de:2710/announce udp://tracker.leechers-paradise.org:6969/announce http://tracker.shuntv.net/announce.php http://tracker.tvunderground.org.ru:3218/announce udp://10.rarbg.me:80/announce udp://9.rarbg.com:2710/announce udp://tracker.yify-torrents.com/announce udp://tracker.coppersurfer.tk:6969/announce http://siambit.org/announce.php udp://open.demonii.com:1337/announce udp://tracker.torrenty.org:6969/announce http://tracker.torrenty.org:6969/announce udp://tracker.publichd.eu:80/announce http://tracker.pimp4003.net/announce http://tracker.xfsub.com:6868/announce http://mgtracker.org:6969/announce http://tr.cili001.com:6666/announce udp://tr.cili001.com:6666/announce http://tracker.openbittorrent.com/announce udp://tracker.opentrackr.org:1337/announce udp://open.demonii.com:1337 udp://9.rarbg.com:2720/announce http://tracker1.wasabii.com.tw:6969/announce Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/glibc.html":{"url":"linux/glibc.html","title":"Linux下安装GLIBC_2.15","summary":"Linux下安装GLIBC_2.15","keywords":"","body":"Linux下安装GLIBC_2-15 1、查看系统glibc支持的版本 # strings /lib64/libc.so.6 |grep GLIBC # rpm -qa | grep glibc 2、升级glibc支持的版本到GLIBC_2.15 官网地址 ➡️ http://www.gnu.org/software/libc/ 官网所有安装包 ➡️ http://ftp.gnu.org/gnu/glibc/ # cd /usr/local # wget http://ftp.gnu.org/gnu/libc/glibc-2.15.tar.xz # tar -xvf glibc-2.15.tar.xz # mkdir -p /var/VMdisks # mv glibc-2.15 /var/VMdisks/ # cd /var/VMdisks/glibc-2.15/ # mkdir build && cd build/ --- 不要将 glibc 安装到默认的目录【/usr/local】或者 【任何自定义的目录】，请务必安装到【/usr】目录 # ../configure --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin # make -j4 # make install --- 解决中文乱码问题 # make localedata/install-locales 检查验证 # ll /lib64/libc* --- 查看系统glibc支持的版本 # strings /lib64/libc.so.6 |grep GLIBC # /lib64/libc.so.6 3、升级glibc挂了后可以救命的命令 如果实在不幸，在升级glibc时挂掉了，执行各种命令都提示错误，比如： Segmentation fault error while loading shared libraries: libc.so.6: cannot open shared object file: No such file or directory 这类错误出现千万不要着急退出SSH，执行下面的命令是可以挽救的： # cd /lib64 # LD_PRELOAD=/lib64/libc-2.12.so ln -sf /lib64/libc-2.12.so libc.so.6 Tips：libc-2.12.so这个文件名根据你系统中的文件而定，如果有多个版本so文件可以逐个尝试 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/python.html":{"url":"linux/python.html","title":"Linux安装python2-7-9","summary":"Linux安装python2.7.9","keywords":"","body":"Linux安装python2.7.9 官网地址：https://www.python.org/downloads/ 1、Linux下安装(其他系统请自行前往官网安装) --- 安装依赖包 # cd /usr/local # yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make -y # wget https://www.python.org/ftp/python/2.7.9/Python-2.7.9.tgz # tar -xzvf Python-2.7.9.tgz # cd Python-2.7.9 # ./configure --prefix=/usr/local/Python2.7.9 --enable-shared -enable-unicode=ucs4 # make # make install # python -V 2、python解释器指向python2.7.9 # which python # cd /usr/bin # rm python # ln -s /usr/local/Python2.7.9/bin/python python # python -V --执行报错 3、解决python -V执行报错 # cd /etc/ld.so.conf.d/ # echo \"/usr/local/Python2.7.9/lib\" > python2.7.conf # ldconfig # python -V 4、由于yum使用了原来python2.6的一些脚本，需要将yum重新导向原来的python2.6解释器才可以使用 # which yum # vi /usr/bin/yum ----修改第一行路径为： #!/usr/bin/python2.6 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/rabbitmq.html":{"url":"linux/rabbitmq.html","title":"Linux下安装rabbitMq","summary":"Linux下安装rabbitMq","keywords":"","body":"Linux下安装rabbitMq Linux下安装rabbitMq 必须有Erlang环境------>>>Linux下安装Erlang 一、安装rabbitMq # cd /usr/local/ # yum install -y xz # wget http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.2/rabbitmq-server-generic-unix-3.6.2.tar.xz # xz -d rabbitmq-server-generic-unix-3.6.2.tar.xz # tar -xvf rabbitmq-server-generic-unix-3.6.2.tar --配置rabbitMq环境变量 # vim /etc/profile 文件末尾添加 export PATH=$PATH:/usr/local/rabbitmq_server-3.6.2/sbin # source /etc/profile 二、配置网页插件 # rabbitmq-plugins enable rabbitmq_management --启动rabbitMq # rabbitmq-server –detached Tips:rabbitmq默认会创建guest账号，只能用于localhost登录页面管理员 --添加admin用户并且密码为admin # rabbitmqctl add_user admin admin --授权admin用户为管理员 # rabbitmqctl set_user_tags admin administrator --授权访问权限 # rabbitmqctl set_permissions -p \"/\" admin \".\" \".\" \".*\" 三、验证rabbitMq是否安装成功 端口：15672 网页管理， 5672 AMQP端口 访问 http://IP:15672 四、rabbitMq常用命令： 启动：rabbitmq-server –detached 查看服务状态：rabbitmqctl status 关闭服务：rabbitmqctl stop 查看所有用户：rabbitmqctl list_users 添加用户：rabbitmqctl add_user admin admin 授权用户管理员：rabbitmqctl set_user_tags admin administrator 授权访问权限：rabbitmqctl set_permissions -p \"/\" admin \".\" \".\" \".*\" 添加虚拟机：rabbitmqctl add_vhost admin_vhost 授权用户到虚拟机：rabbitmqctl set_permissions -p admin_vhost admin \".*\" \".*\" \".*\" Tips:RabbitMQ与Erlang的版本对应关系图 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/erlang.html":{"url":"linux/erlang.html","title":"Linux下安装Erlang","summary":"Linux下安装Erlang","keywords":"","body":"Linux下安装Erlang Linux下安装Erlang 一、升级openssl # cd /usr/local/ # wget http://www.openssl.org/source/openssl-1.0.1s.tar.gz # tar -zxvf openssl-1.0.1s.tar.gz # cd openssl-1.0.1s # ./config --prefix=/usr/local/openssl # vim Makefile --修改CFLAG= -DOPENSSL_THREADS 修改成 CFLAG= -fPIC -DOPENSSL_THREADS --也就是添加 -fPIC # make && make install 二、安装Erlang # cd /usr/local/ # wget http://erlang.org/download/otp_src_18.3.tar.gz # tar -zxvf otp_src_18.3.tar.gz # cd otp_src_18.3 --创建Erlang安装目录 # mkdir /usr/local/erlang --ErLang安装依赖 # yum install -y gcc gcc-c++ unixODBC-devel openssl-devel ncurses-devel # ./configure --prefix=/usr/local/erlang # make && make install --配置Erlang环境变量 # vim /etc/profile 文件末尾添加 export PATH=$PATH:/usr/local/erlang/bin # source /etc/profile 三、验证erlang是否安装成功 # erl # ssl:versions(). # halt(). Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/command.html":{"url":"linux/command.html","title":"Linux常用命令","summary":"Linux常用命令","keywords":"","body":"Linux常用命令 命令格式与目录处理命令ls 命令格式与目录处理命令 ls 命令格式：命令 [-选项][参数] 例：ls -la /etc 说明： 1）个别命令使用不遵循格式 2）当有多个选项时，可以写在一起 3）简化选项与完整选项 -a 等于 --all 目录处理命令 ls 命令名称：ls 命令因为原意：list 命令所在路径：/bin/ls 执行权限：所有用户 功能描述：显示目录文件 语法：ls 选项[-ald][文件或目录] -a 显示所有文件，包括隐藏文件 -l 详细信息显示 -d 查看目录属性 -rw-r–r– 文件类型（-文件 d目录 l软链接文件） rw- r– r– u g o u所有者 g所属组 o其他人 r读 w写 x执行 目录处理命令 命令名称：mkdir 命令因为原意：make directories 命令所在路径：/bin/mkdir 执行权限：所有用户 执行权限：所有用户 功能描述：创建新目录 -p 递归创建 例：mkdir -p/tmp/japan/hanmeimei mkdir /tmp/japan/lilei /tmp/japan/hanmeimei 命令名称：cd 命令因为原意：change directory 命令所在路径：shell内置命令 执行权限：所有用户 语法：cd [目录名] 功能描述：切换目录 例：cd /tmp/japan/hanmeimei 切换到指定目录 cd .. 回到上一级目录 命令名称：pwd 命令因为原意：print working directory 命令所在路径：/bin/pwd 执行权限：所有用户 语法：pwd 功能描述：显示当前目录 范例：$ pwd 命令名称：rmdir 命令因为原意：remove empty directories 命令所在路径：/bin/rmdir 执行权限：所有用户 语法：rmdir [目录名] 功能描述：删除空目录 范例：$ rmdir /tmp/japan/lilei 命令名称：cp 命令因为原意：copy 命令所在路径：/bin/cp 执行权限：所有用户 语法:cp -rp [原文件或目录][目标目录] -r 复制目录 -p 保存文件属性 功能描述：复制文件或目录 范例：$ cp -r /tmp/japan/hanmeimei /root 将目录/tmp/japan/hanmeimei 复制到目录/root下 cp -rp /tmp/japan/hameimei /tmp/japan/lilei /root 将/tmp/japan目录下的hanmeimei和lilei目录复制到root下，并保持目录属性 命令名称：mv 命令因为原意：move 命令所在路径：/bin/mv 执行权限：所有用户 语法:mv [原文件或目录][目标目录] 功能描述：剪切文件、改名 命令名称：rm 命令因为原意：remove 命令所在路径：/bin/rm 执行权限：所有用户 语法:rm -rf[文件或目录] -r 删除目录 -f 强制执行 功能描述：删除文件 范例：$ rm /tmp/yum.log 删除文件/tmp/yum.log rm -rf /tmpjapan/lilei 删除目录/tmp/japan/lilei 文件处理命令 命令名称：touch 命令所在路径：/bin/touch 执行权限：所有用户 语法:touch [文件名] 功能描述：创建空文件 范例：$ touch log.log 命令名称：cat 命令所在路径：/bin/cat 执行权限：所有用户 语法:cat [文件名] 功能描述：显示文件内容 -n 显示行号 范例：$ cat /etc/issue cat -n /etc/services 命令名称：tac 命令所在路径：/usr/bin/tac 执行权限：所有用户 语法:tac [文件名] 功能描述：显示文件内容(反向列示) 范例：$ tac /etc/issue 命令名称：more 命令所在路径：/bin/more 执行权限：所有用户 语法:more [文件名] (空格)或f 翻页 (Enter) 换行 q或Q 退出 功能描述：分页显示文件内容 范例：$ more /etc/services 命令名称：less 命令所在路径：/usr/bin/less 执行权限：所有用户 语法:less [文件名] 功能描述：分页显示文件内容(可向上翻页) 范例：$ less /etc/services 命令名称：head 命令所在路径：/usr/bin/head 执行权限：所有用户 语法:head [文件名] 功能描述：显示文件前面几行 -n 指定行数 范例：$ head -n 20 /etc/services 命令名称：tail 命令所在路径：/usr/bin/tail 执行权限：所有用户 语法:tail [文件名] 功能描述：显示文件后面面几行 -n 指定行数 -f 动态显示文件末尾内容 范例：$ tail -n 18 /etc/services 命令名称：ln 命令英文原意：link 命令所在路径：/bin/link 执行权限：所有用户 语法:ls -s [原文件][目标文件] -s 创建软链接 功能描述：生成链接文件 范例：$ ln -s /etc/issue /tmp/issue.soft 创建文件/etc/issue的软链接/tmp/issue.soft ln /etc/issue /tmp/issue.hard 创建文件/etc/issue的硬链接/tmp/issue.hard 软链接特征：类似Windows快捷方式 1.1rwxrwxrwx 1软链接 软链接文件权限都为rwxrwxrwx 2、文件大小-只是符号链接 3、/tmp/issue.soft->/etc/issue 箭头指向原文件 硬链接特征： 1.拷贝cp -p + 同步更新 echo \"this is a test\" >> /etc/motd 2.可通过i节点识别 3.不能跨分区 4.不能针对目录使用 权限管理命令 命令名称：chmod 命令英文原意：change the permissions mode of a file 命令所在路径：/bin/chmod 执行权限：所有用户 语法：chmod [{ugoa}{+-=}{rwx}] [文件或目录] [mode=421 ] [文件或目录] -R 递归修改 功能描述：改变文件或目录权限 权限的数字表示 权限的数字表示 r 4 w 2 x 1 范例：$ rwxrw-r-- 7 6 4 范例：$ chmod g+w testfile 赋予文件testfile所属组写权限 chmod -R 777 testdir 修改目录testfile及其目录下文件为所有用户具有全部权限 其他权限命令 命令名称：chown 命令英文原意：change file ownership 命令所在路径：/bin/chown 执行权限：所有用户 语法：chown [用户] [文件或目录] 功能描述：改变文件或目录的所有者 范例：$ chown hanmeimei beijian 改变文件beijian的所有者为hanmeimei 命令名称：chgrp 命令英文原意：change file group ownership 命令所在路径：/bin/chgrp 执行权限：所有用户 语法：chgrp [用户组] [文件或目录] 功能描述：改变文件或目录的所属组 范例：$ chgrp hmeimei beijing 改变文件beijing的所属组为hanmeimei 命令名称：umask 命令英文原意：the user file-creation mask 命令所在路径：Shell内置命令 执行权限：所有用户 语法：umask [-S] -S 以rwx形式显示新建文件缺省权限 功能描述：显示、设置文件的缺省权限 范例：$ umask -S 文件搜索命令 命令名称：find 命令所在路径：/bin/find 执行权限：所有用户 语法：find [搜索范围] [匹配条件] 功能描述：文件搜索 范例：$ find /etc -name init 在目录/etc中查找文件init -iname 不区分大小写 find / -size +204800 在根目录下查找大于100MB的文件 +n 大于 -n 小于 n 等于 find /home -user hanmeimei 在根目录下查找所有者为hanmeimei的文件 -group 根据所属组查找 find /etc -cmin -5 在/etc下查找5分钟内被修改过属性的文件和目录 -amin 访问时间 access -cmin 文件属性 change -mmin 文件内容 modify find /etc -size +163840 -a -size -204800 在/etc下查找大于80MB小于100MB的文件 -a 两个条件同时满足 -o 两个条件满足任意一个即可 find /etc -name inittab -exec ls -l {} \\; 在/etc下查找inittab文件并显示其详细信息 -exec/-ok 命令 {} \\; 对搜索结果执行操作 -type 根据文件类型查找 f 文件 d 目录 l 软链接文件 -inum 根据i节点查找 命令名称：locate 命令所在路径：/usr/bin/locate 执行权限：所有用户 语法：locate 文件名 功能描述：在文件资料库中查找文件 范例：$ locate inittab 命令名称：which 命令所在路径：/usr/bin/which 执行权限：所有用户 语法：which 命令 功能描述：搜索命令所在目录及别名信息 范例：$ which ls 命令名称：whereis 命令所在路径：/usr/bin/whereis 执行权限：所有用户 语法：whereis [命令名称] 功能描述：搜索命令所在目录及帮助文档路径 范例：$ whereis ls 命令名称：grep 命令所在路径：/bin/grep 执行权限：所有用户 语法：grep -iv [指定字串] [文件] 功能描述：在文件中搜寻字串匹配的行并输出 -i 不区分大小写 -v 排除指定字串 范例：# grep mysql /root/install.log 帮助命令 命令名称：man 命令英文原意：manual 命令所在路径：/usr/bin/man 执行权限：所有用户 语法：man [命令或配置文件] 功能描述：获得帮助信息 范例： $ man ls 查看ls命令的帮助信息 $ man services 查看配置文件services的帮助信息 命令名称：help 命令所在路径：Shell内置命令 执行权限：所有用户 语法：help 命令 功能描述：获得Shell内置命令的帮助信息 范例： $ help umask 查看umask命令的帮助信息 用户管理命令 命令名称：useradd 命令所在路径：/usr/sbin/useradd 执行权限：root 语法：useradd 用户名功能描述：添加新用户 功能描述：添加新用户 范例： $ useradd lilei 命令名称：passwd username 命令所在路径：/usr/bin/passwd 执行权限：所有用户 语法：passwd 用户名 功能描述：设置用户密码 范例： $ passwd lilei 命令名称：who 命令所在路径：/usr/bin/who 执行权限：所有用户 语法：who 功能描述：查看登录用户信息 范例： $ who 命令名称：w 命令所在路径：/usr/bin/w 执行权限：所有用户 语法：w 功能描述：查看登录用户详细信息 范例： $ w 压缩解压命令 命令名称：gzip(只能压缩文件，不能压缩目录) 命令英文原意：GNU zip 命令所在路径：/bin/gzip 执行权限：所有用户 语法：gzip [文件] 功能描述：压缩文件 压缩后文件格式：.gz 命令名称：gunzip(解压) 命令英文原意：GNU unzip 命令所在路径：/bin/gunzip 执行权限：所有用户 语法：gunzip [压缩文件] 功能描述：解压缩.gz的压缩文件 范例： $ gunzip boduo.gz 命令名称：tar 命令所在路径：/bin/tar 执行权限：所有用户 语法：tar 选项[-zcf] [压缩后文件名] [目录] -c 打包 -v 显示详细信息 -f 指定文件名 -z 打包同时压缩 功能描述：打包目录 压缩后文件格式：.tar.gz 范例：$ tar -zcf Japan.tar.gz Japan 将目录Japan打包并压缩为.tar.gz文件 tar命令解压缩语法: -x 解包 -v 显示详细信息 -f 指定解压文件 -z 解压缩 范例：$ tar -zxvf Japan.tar.gz 命令名称：zip 命令所在路径：/usr/bin/zip 执行权限：所有用户 语法：zip 选项[-r] [压缩后文件名] [文件或目录] -r 压缩目录 功能描述：压缩文件或目录 压缩后文件格式：.zip 范例：$ zip buduo.zip boduo 压缩文件 $ zip -r Japan.zip Japan 压缩目录 命令名称：unzip 命令所在路径：/usr/bin/unzip 执行权限：所有用户 语法：unzip [压缩文件] 功能描述：解压.zip的压缩文件 范例：$ unzip test.zip 命令名称：bzip2 命令所在路径：/usr/bin/bzip2 执行权限：所有用户 语法： bzip2 选项 [-k] [文件] -k 产生压缩文件后保留原文件 功能描述：压缩文件 压缩后文件格式：.bz2 范例：$ bzip2 -k boduo $ tar -cjf Japan.tar.bz2 Japan 命令名称：bunzip2 命令所在路径：/usr/bin/bunzip2 执行权限：所有用户 语法： bunzip2 选项 [-k] [压缩文件] -k 解压缩后保留原文件 功能描述：解压缩 范例：$ bunzip2 -k boduo.bz2 $ tar -xjf Japan.tar.bz2 网络命令 指令名称：write 指令所在路径：/usr/bin/write 执行权限：所有用户 语法：write 功能描述：给用户发信息，以Ctrl+D保存结束 范例： # write linzhiling 命令名称：ping 命令所在路径：/bin/ping 执行权限：所有用户 语法：ping 选项 IP地址 -c 指定发送次数 功能描述：测试网络连通性 范例： # ping 192.168.1.156 命令名称：ifconfig 命令英文原意：interface configure 命令所在路径：/sbin/ifconfig 执行权限：root 语法：ifconfig 网卡名称 IP地址 功能描述：查看和设置网卡信息 范例：# ifconfig eth0 192.168.8.250 命令名称：mail 命令所在路径：/bin/mail 执行权限：所有用户 语法：mail [用户名] 功能描述：查看发送电子邮件 范例：# mail root 命令名称：last 命令所在路径：/usr/bin/last 执行权限：所有用户 语法：last 功能描述：列出目前与过去登入系统的用户信息 范例：# last 命令名称：lastlog 命令所在路径：/usr/bin/lastlog 执行权限：所有用户 语法：lastlog 功能描述：检查某特定用户上次登录的时间 范例：# lastlog # lastlog -u 502 命令名称：traceroute 命令所在路径：/bin/traceroute 执行权限：所有用户 语法：traceroute 功能描述：显示数据包到主机间的路径 范例：# traceroute www.baidu.com 命令名称：netstat 命令所在路径：/bin/netstat 执行权限：所有用户 语法：netstat [选项] 功能描述：显示网络相关信息 选项： -t ： TCP协议 -u ： UDP协议 -l ： 监听 -r ： 路由 -n ： 显示IP地址和端口号 范例： # netstat -tlun 查看本机监听的端口 # netstat -an 查看本机所有的网络连接 # netstat -rn 查看本机路由表 命令名称：setup 命令所在路径：/usr/bin/setup 执行权限：root 语法：setup 功能描述：配置网络 范例：# setup 命令名称：mount 命令位置：/bin/mount 执行权限：所有用户 命令语法：mount [-t 文件系统] 设备文件名 挂载点 范例：# mount -t iso9660 /dev/sr0 /mnt/cdrom 关机重启命令 shutdown [选项] 时间 选项： -c： 取消前一个关机命令 -h： 关机 -r： 重启 其他关机命令 # halt # poweroff # init 0 其他重启命令 # reboot # init 6 系统运行级别 0 关机 1 单用户 2 不完全多用户，不含NFS服务 3 完全多用户 4 未分配 5 图形界面 6 重启 修改系统默认运行级别 # cat /etc/inittab id:3:initdefault: 查询系统运行级别 # runlevel 退出登录命令 # logout Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/view_hardware.html":{"url":"linux/view_hardware.html","title":"Linux查看硬件信息","summary":"Linux查看硬件信息","keywords":"","body":"Linux查看硬件信息 系统 # uname -a # 查看内核/操作系统/CPU信息 # head -n 1 /etc/issue # 查看操作系统版本 # cat /proc/cpuinfo # 查看CPU信息 # hostname # 查看计算机名 # lspci -tv # 列出所有PCI设备（yum install pciutils） # lsusb -tv # 列出所有USB设备 # lsmod # 列出加载的内核模块 # env # 查看环境变量 资源 # free -m # 查看内存使用量和交换区使用量 # df -h # 查看各分区使用情况 # du -sh # 查看指定目录的大小 # grep MemTotal /proc/meminfo # 查看内存总量 # grep MemFree /proc/meminfo # 查看空闲内存量 # uptime # 查看系统运行时间、用户数、负载 # cat /proc/loadavg # 查看系统负载 磁盘和分区 # mount | column -t # 查看挂接的分区状态 # fdisk -l # 查看所有分区 # swapon -s # 查看所有交换分区 # hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备) # dmesg | grep IDE # 查看启动时IDE设备检测状况 网络 # ifconfig # 查看所有网络接口的属性 # iptables -L # 查看防火墙设置 # route -n # 查看路由表 # netstat -lntp # 查看所有监听端口 # netstat -antp # 查看所有已经建立的连接 # netstat -s # 查看网络统计信息 进程 # ps -ef # 查看所有进程 # top # 实时显示进程状态 用户 # w # 查看活动用户 # id # 查看指定用户信息 # last # 查看用户登录日志 # cut -d: -f1 /etc/passwd # 查看系统所有用户 # cut -d: -f1 /etc/group # 查看系统所有组 # crontab -l # 查看当前用户的计划任务 服务 # chkconfig --list # 列出所有系统服务 # chkconfig --list | grep on # 列出所有启动的系统服务 程序 # rpm -qa # 查看所有安装的软件包 查看网卡型号 # lspci | grep Ethernet 查看内存和cpu最直接最常用的命令 # free # cat /proc/cpuinfo 查看硬盘信息（查看硬盘型号和硬盘序列号） # df -h Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/time.html":{"url":"linux/time.html","title":"Linux下同步网络时间","summary":"Linux下同步网络时间","keywords":"","body":"Linux下同步网络时间 一、安装ntp # yum install -y ntpdate 二、同步时间 # 方式一、使用域名连接，要经过DNS解析，速度慢。 # ntpdate pool.ntp.org # 方式二、使用IP连接，超级快。 # ntpdate 120.24.81.91 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/node.html":{"url":"linux/node.html","title":"Linux或Win下安装node和npm","summary":"Linux或Win下安装node和npm","keywords":"","body":"Linux或Win下安装node和npm 一、离线安装Node 官网下载链接：https://nodejs.org/zh-cn/download/ node和npm对应关系：https://nodejs.org/zh-cn/download/releases/ 解压目录 # cd /usr/local # yum install -y xz # xz -d node-v8.11.1-linux-x64.tar.xz # tar -xf node-v8.11.1-linux-x64.tar 这里想要全局使用npm 和 node,就需要做相关软链，如下！ # cd /usr/local/bin # ln -s /usr/local/src/node-v8.10.0-linux-x64/bin/npm # ln -s /usr/local/src/node-v8.10.0-linux-x64/bin/node 然后即可在任意位置执行 node -v npm -v 查看相应的版本，则安装完成！ 二、yum安装node和npm(Linux快速安装) # yum install epel-release -y # yum install nodejs -y 三、使用淘宝镜像站(建议跳过此步骤，不建议使用) # npm config get registry // https://registry.npmjs.org/ # npm config set registry https://registry.npm.taobao.org ---- 验证是否配置成功 # npm config get registry 四、指定全局安装路径和缓存路径(看自己选择是否使用) 设置全局模块的安装路径到 node_global 文件夹， 设置缓存到 node_cache 文件夹 # npm config set prefix D:\\nodejs\\node_global # npm config set cache D:\\nodejs\\node_cache ---- 验证是否配置成功 # npm config get cache # npm ls -g 五、安装 cnpm(看自己选择是否使用) # npm install cnpm -g --registry=https://registry.npm.taobao.org # cnpm -v Tips: npm默认的全局目录可执行命令查看# npm config ls Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/git.html":{"url":"linux/git.html","title":"Linux下安装Git","summary":"Linux下安装Git","keywords":"","body":"Linux下安装Git 1、使用yum安装 # yum -y install git # yum remove git 2、源代码安装 ---安装依赖的包 # yum -y install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker zlib # cd /usr/local ----下载git源码 # wget https://github.com/git/git/archive/v2.21.0.tar.gz ----解压git源码 # tar -zxvf v2.21.0.tar.gz # cd git-2.21.0/ # mkdir /usr/local/git ----编译安装到指定目录 # make prefix=/usr/local/git all # sudo make prefix=/usr/local/git install # vim /etc/profile ----添加在文件的最后一行 export PATH=/usr/local/git/bin:$PATH # source /etc/profile # git --version 3、FAQ 1、 如果解压时出现报错，建议手动下载git源码包然后上传到服务器 gzip: stdin: unexpected end of file tar: Unexpected EOF in archive tar: Unexpected EOF in archive tar: Error is not recoverable: exiting now Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/tomcat_config.html":{"url":"linux/tomcat_config.html","title":"Linux下Tomcat指定JDK和设置内存大小","summary":"Linux下Tomcat指定JDK和设置内存大小","keywords":"","body":"Linux下Tomcat指定JDK和设置内存大小 一、Linux下Tomcat指定JDK # vim bin/setclasspath.sh 在脚本开头的地方指定JAVA_HOME和JRE_HOME export JAVA_HOME=/usr/local/jdk1.8.0_40 export JRE_HOME=/usr/local/jdk1.8.0_40/jre 二、Linux下Tomcat设置内存大小 # vim bin/catalina.sh Tomcat设置内存为8G:JAVA_OPTS=\"-server -Xms8192M -Xmx8192M -XX:PermSize=256M -XX:MaxPermSize=256M\" Tomcat设置内存为4G:JAVA_OPTS=\"-server -Xms4096M -Xmx4096M -XX:PermSize=256M -XX:MaxPermSize=256M\" Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/nohup.html":{"url":"linux/nohup.html","title":"nohup和>/dev/null 2>&1","summary":"nohup 和 >/dev/null 2>&1","keywords":"","body":"nohup 和 >/dev/null 2>&1 一、用途：nohup表示永久运行 &表示后台运行 在应用Unix/Linux时，我们一般想让某个程序在后台运行 # nohup ./start-mysql.sh & 该命令的一般形式为： # nohup command & 在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中,除非另外指定了输出文件： # nohup command > myout.file 2>&1 & 在上面的例子中，输出被重定向到myout.file文件中。 二、>/dev/null 2>&1 /dev/null代表空设备文件，也就是不输出任何信息到终端，说白了就是不显示任何信息。 # nohup command 1>/dev/null 2>&1 & Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/selinux.html":{"url":"linux/selinux.html","title":"Linux临时和永久关闭selinux","summary":"Linux临时和永久关闭selinux","keywords":"","body":"Linux临时和永久关闭selinux 临时关闭： # setenforce 0 永久关闭： # vim /etc/sysconfig/selinux SELINUX=enforcing 改为 SELINUX=disabled -- 重启生效 # reboot Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/vim.html":{"url":"linux/vim.html","title":"vi-vim-粘贴内容时,保留原文件内容格式","summary":"vi-vim-粘贴内容时,保留原文件内容格式","keywords":"","body":"vi-vim-粘贴内容时,保留原文件内容格式 在vi/vim普通模式下执行:set paste命令，再按 i 插入就会保留原文件格式 :set paste 打开粘贴命令 :set nopaste 关闭命令 :h paste 帮助 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/mysql.html":{"url":"linux/mysql.html","title":"CentOS6.5-离线安装MySQL5.6.26","summary":"CentOS6-5-离线安装MySQL5-6-26","keywords":"","body":"CentOS6-5-离线安装MySQL5-6-26 1、卸载之前安装的MySQL # rpm -qa | grep mysql --查看系统之前是否已安装MySQL。 # rpm -e --nodeps mysql-libs-5.1.71-1.el6.x86_64 --执行删除语句 # rm -rf /var/lib/mysql* --善后处理 # rm -rf /usr/share/mysql* 2、安装MySQL 2.1、下载并安装 libaio # cd /usr/local # wget http://mirror.centos.org/centos/6/os/x86_64/Packages/libaio-0.3.107-10.el6.x86_64.rpm # rpm -ivh libaio-0.3.107-10.el6.x86_64.rpm 2.2、下载并安装MySQL # cd /usr/local # wget https://dev.mysql.com/get/archives/mysql-5.6/MySQL-5.6.26-1.linux_glibc2.5.x86_64.rpm-bundle.tar # tar -xf MySQL-5.6.26-1.linux_glibc2.5.x86_64.rpm-bundle.tar # rpm -ivh MySQL-server-5.6.26-1.linux_glibc2.5.x86_64.rpm # rpm -ivh MySQL-client-5.6.26-1.linux_glibc2.5.x86_64.rpm 2.3、查看并修改MySQL root用户密码 # more /root/.mysql_secret # service mysql restart # mysqladmin -uroot -pFeyU2YjwMcAw9Nv0 password 'root' --修改root密码为root # mysql -uroot -proot --测试登陆 2.4、配置MySQL数据库编码 # cp -rp /usr/share/mysql/my-default.cnf /etc/my.cnf # 在mysqld下面增加 init-connect='SET NAMES utf8' character-set-server = utf8 # service mysql restart # mysql -uroot -proot --验证是否成功 # show variables like 'character%'; 2.5、配置MySQL远程访问 # service iptables stop # chkconfig iptables off # mysql -uroot -proot # grant all privileges on *.* to root@'%' identified by 'root' WITH GRANT OPTION; # flush privileges; Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/mysql_storage.html":{"url":"linux/mysql_storage.html","title":"更改MySQL的存储目录","summary":"更改MySQL的存储目录","keywords":"","body":"更改MySQL的存储目录 重要步骤：一定要先停止Mysql # service mysqld stop 1、创建目标文件夹 # mkdir -p /data/mysql # chown -R mysql.mysql /data/mysql/ 2、迁移命令 # mysql_install_db --user=mysql --basedir=/usr --datadir=/data/mysql 3、为避免麻烦，删掉原文件夹/var/lib/mysql # rm -rf /var/lib/mysql/* 4、修改/etc/my.cnf配置文件 [mysqld] datadir=/data/mysql 5、启动mysql # chkconfig mysqld on # service mysqld restart Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/linux_mysql_log.html":{"url":"linux/linux_mysql_log.html","title":"Linux开启MySQL日志","summary":"Linux开启MySQL日志","keywords":"","body":"Linux开启MySQL日志 # vim /etc/my.cnf 如果里面存在 !includedir /etc/my.cnf.d 则 # vim /etc/my.cnf.d/server.cnf 没有就是 # vim /etc/my.cnf #在mysqld标签下添加 #指定错误日志保存位置 log-error=/test_log/mysql_log/error.log #开启通用查询日志 general_log=ON #指定通用查询日志保存位置 general_log_file=/test_log/mysql_log/mysql.log #开启慢查询日志 slow_query_log=on #记录超过1秒的SQL执行语句 long_query_time=1 #指定慢查询日志的保存位置 slow-query-log-file=/test_log/mysql_log/slowquery.log 重启MySQL service mysqld restart Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/mariadb_config.html":{"url":"linux/mariadb_config.html","title":"解决MariaDB中文乱码","summary":"解决MariaDB中文乱码","keywords":"","body":"解决MariaDB中文乱码 1、检查自己数据库编码 # mysql -uroot -proot # show VARIABLES like 'char%'; 2、更改Client和Server编码都是UTF-8 # vim /etc/my.cnf.d/server.cnf 在server.cnf中[mysqld]标签下添加代码 init-connect='SET NAMES utf8' character-set-server = utf8 重启MariaDB即可 # systemctl restart mariadb --- 如果已经添加为服务 # service mysqld restart Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/virtualbox.html":{"url":"linux/virtualbox.html","title":"CentOS-6.X-安装VirtualBox-5.1","summary":"CentOS-6-X-安装VirtualBox-5.1","keywords":"","body":"CentOS-6-X-安装VirtualBox-5.1 一、安装virtualbox的yum源 # vim /etc/yum.repos.d/virtualbox.repo # 添加以下内容 [virtualbox] name=Oracle Linux / RHEL / CentOS-$releasever / $basearch - VirtualBox baseurl=http://download.virtualbox.org/virtualbox/rpm/el/$releasever/$basearch enabled=1 gpgcheck=1 gpgkey=http://download.virtualbox.org/virtualbox/debian/oracle_vbox.asc 二、添加EPEL源 # rpm -Uvh http://download.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm 三、添加必要的依赖包 # yum install -y gcc make patch dkms qt libgomp # yum install -y kernel-headers kernel-devel fontforge binutils glibc-headers glibc-devel # yum install -y kernel kernel-headers kernel-devel gcc make 四、设置环境变量，主要是内核的路径 # vim /etc/profile # 文件最后行添加 export KERN_DIR=/usr/src/kernels/你的最新内核版本xxx # source /etc/profile 五、安装virtualbox # yum search VirtualBox # yum install -y VirtualBox-5.1 # reboot # 重新编译与virtualbox相关的内核模块 # service vboxdrv setup # 启动virtualbox # virtualbox & Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/vnc_server.html":{"url":"linux/vnc_server.html","title":"CentOS-6.X-安装VNC-Server实现图形化访问","summary":"CentOS-6.X-安装VNC-Server实现图形化访问","keywords":"","body":"CentOS-6.X-安装VNC-Server实现图形化访问 一、安装gnome图形化桌面 # yum groupinstall -y \"X Window System\" # yum groupinstall -y \"Desktop\" # yum groupinstall -y \"Chinese Support\" 二、安装vncserver（vnc是一款优秀的远程控制软件） # yum install -y tigervnc-server 三、配置vncserver # ---配置为开机自启动 # chkconfig --level 345 vncserver on # ---配置vnc密码 # vncserver # ---配置为使用gnome桌面 # ---修改文件xstratup # vim /root/.vnc/xstartup 把最后的 twm & 删掉 加上 gnome-session & # ---配置vncserver启动后监听端口和环境参数 # vim /etc/sysconfig/vncservers # ---在文件末添加以下内容 VNCSERVERS=\"1:root\" VNCSERVERARGS[1]=\"-geometry 1200x800\" # ---重启vncserver服务 # service vncserver restart 四、允许root访问图形界面和生成新的machine-id # sed -i 's/.*!= root.*/#&/' /etc/pam.d/gdm # dbus-uuidgen > /var/lib/dbus/machine-id 五、关闭selinux和NetworkManager服务 1.检查selinux服务并关闭(确认里面的SELINUX字段的值是disabled，如果不是则改为disabled) # vim /etc/selinux/config 2.关闭NetworkManager服务 # chkconfig --del NetworkManager 安装vncviewer客户端输入IP:1 输入密码访问即可 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/visual.html":{"url":"linux/visual.html","title":"CentOS-6.X-图形界面安装","summary":"CentOS-6.X-图形界面安装","keywords":"","body":"CentOS-6.X-图形界面安装 一、安装图形界面 # yum groupinstall -y \"Desktop\" \"Desktop Platform\" \"Fonts\" \"General Purpose Desktop\" \"Graphical Administration Tools\" \"Input Methods\" \"Legacy X Window System compatibility\" \"Remote Desktop Clients\" \"X Window System\" # vi /etc/inittab # 修改最后一行为id:5:initdefault: # startx # reboot 二、安装中文输入法(可选) # yum -y install \"@Chinese Support\" Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/apache.html":{"url":"linux/apache.html","title":"Linux中Apache(httpd)安装、配置","summary":"Linux中Apache(httpd)安装、配置","keywords":"","body":"Linux中Apache(httpd)安装、配置 1、yum安装 --- 先yum list看看有没有你可以的包 # yum list httpd --- 如果有的话，比如我用x86_64版，就可以安装 # yum install httpd.x86_64 2、配置、启动Apache 2.1、httpd.conf是主配置文件，你可以按需更改，一般来说可能需要自定义端口，那么就vim修改httpd.conf文件的监听端口，改为你希望的 查找httpd.conf文件位置 # find / -name httpd.conf 2.2、启动、关闭、重启 # ./apachectl start # ./apachectl stop # ./apachectl restart 一般此文件在 /usr/sbin 目录下 3、Apache设置为Linux系统服务，并开机启动 3.1、将链接apachectl复制到系统启动目录下并命名为httpd # cp /usr/local/httpd/bin/apachectl /etc/rc.d/init.d/httpd 到此，其实已经可以使用service httpd start等命令，但在linux服务列表还没有注册 3.2、使用chkconfig来注册apache服务，并其可以在linux的服务列表中看到（chkconfig --list） 在init.d的httpd链接文件中第2行添加如下注释，并wq保存退出 # vim /etc/rc.d/init.d/httpd 将httpd配置自启并加入linux服务监控 # chkconfig --add httpd 全局可以使用命令： # service httpd start # service httpd stop # service httpd restart Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/linux_apache.html":{"url":"linux/linux_apache.html","title":"Linux-Apache服务不能访问文件解决方案","summary":"Linux-Apache服务不能访问文件解决方案","keywords":"","body":"Linux-Apache服务不能访问文件解决方案 httpd服务url地址不能访问文件 请先关闭selinux再reboot重启 关闭selinux # vim /etc/selinux/config SELINUX更改为 SELINUX=disabled # reboot 重启后访问http地址ok Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/orange.html":{"url":"linux/orange.html","title":"Linux安装OpenResty-api-网关-Orange","summary":"Linux安装OpenResty-api-网关-Orange","keywords":"","body":"Linux安装OpenResty-api-网关-Orange 1.安装openresty # yum -y install libuuid-devel pcre-devel openssl-devel gcc-c++ wget # mkdir /openresty # cd /openresty # wget https://openresty.org/download/openresty-1.9.15.1.tar.gz # tar -zxf openresty-1.9.15.1.tar.gz # cd openresty-1.9.15.1 # ./configure --with-http_stub_status_module --with-http_v2_module --with-http_ssl_module # gmake && gmake install # ln -s /usr/local/openresty/nginx/sbin/nginx /usr/sbin/nginx # nginx -v 2.创建MySQL数据库并导入数据(脚本在orange/install文件夹下) # yum -y install mariadb-server # mysql -u root # CREATE DATABASE orange CHARACTER SET utf8 COLLATE utf8_general_ci; # CREATE USER 'orange'@'%' IDENTIFIED BY 'orange'; # GRANT ALL PRIVILEGES ON orange.* TO 'orange'@'%'; # FLUSH PRIVILEGES; # 最后一定要执行mysql的数据库导入。 # mysql -u orange -porange -h 10.0.2.15 orange 3.安装Orange Tips:安装之前需要 lor 框架，否则启动有问题。 # yum install -y git # git clone https://github.com/sumory/lor.git # cd lor # make install 启动并配置 orange 服务 # service iptables stop # chkconfig iptables off # git clone https://github.com/sumory/orange.git # cd orange # vim conf/orange.conf # sh start.sh 访问地址: http://IP:9999 Tips:启动不起来查看端口占用情况杀掉其他进程 # netstat -tunlp |grep 80 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/gitlab.html":{"url":"linux/gitlab.html","title":"Linux搭建GitLab并汉化","summary":"Linux搭建GitLab并汉化","keywords":"","body":"Linux搭建GitLab并汉化 一、环境准备 1.1、下载wget # yum install -y vim # yum install -y wget # cd /usr/local # wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el6/gitlab-ce-10.0.2-ce.0.el6.x86_64.rpm 1.2、关闭防火墙 # service iptables stop # chkconfig iptables off 二、获取GitLab汉化包（要部署非汉化版，可以跳过这一块内容） 2.1、安装Git # yum install -y git 2.2、克隆获取汉化版本库 # cd /usr/local # git clone https://gitlab.com/xhang/gitlab.git 三、部署社区版GitLab 3.1、安装GitLab的依赖项 # yum -y install policycoreutils openssh-server openssh-clients postfix cronie policycoreutils-python 3.2、启动postfix，并设置为开机启动 # service postfix start # chkconfig postfix on 3.3、安装rpm包 # cd /usr/local # rpm -ivh gitlab-ce-10.0.2-ce.0.el6.x86_64.rpm 3.4、修改配置文件gitlab.rb # vim /etc/gitlab/gitlab.rb 将external_url变量的地址修改为gitlab所在centos的ip地址 修改GitLab默认端口 unicorn['port'] = '9092' 因为修改了配置文件，故需要重新加载配置内容。 # gitlab-ctl reconfigure # gitlab-ctl restart 四、覆盖汉化包 4.1、停止GitLab服务 # gitlab-ctl stop 4.2、比较汉化标签和原标签，导出 patch 用的 diff 文件到/root下 # cd /usr/local/gitlab # git diff v10.0.2 v10.0.2-zh > ../10.0.2-zh.diff 4.3、将10.0.2-zh.diff作为补丁更新到GitLab中 # cd /usr/local # yum install patch -y # patch -d /opt/gitlab/embedded/service/gitlab-rails -p1 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/sshkey_github.html":{"url":"linux/sshkey_github.html","title":"Linux配置SSH-Key到GitHub","summary":"Linux配置SSH-Key到GitHub","keywords":"","body":"Linux配置SSH-Key到GitHub 1、生成SSH Key 首先检查下本机是否已经安装了SSH，在终端输入ssh即可： 如果没有安装进行yum安装 # yum -y install openssh-clients 接下来就是生成ssh key了，输入ssh-keygen -t rsa，然后连续按回车键三次（注意：千万不要输入密码！）。 id_rsa.pub为公钥，id_rsa为私钥，它们都是隐藏文件。 那么如何查看它们的内容呢？只需要继续执行以下两条命令即可。 # cd .ssh/ # cat id_rsa.pub 2、添加SSH Key到GitHub上 接着执行下面操作： 点击New SSH Key按钮后进行Key的填写操作，完成SSH Key的添加。如下图： 添加SSH Key成功之后，继续输入命令进行测试。 # ssh -T git@github.com 出现上图结果则说明添加SSH Key成功。 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/fsck_unresolve.html":{"url":"linux/fsck_unresolve.html","title":"Linux下fsck-ext4-Unable-to-resolve问题记录","summary":"Linux下fsck-ext4-Unable-to-resolve问题记录","keywords":"","body":"Linux下fsck-ext4-Unable-to-resolve问题记录 linux启动报错: 由于其他原因将分区UUID为e29667b7-.... 删除了，重启系统发现fsck 文件系统时failed 问题解决： 在(or type control -D to continue):后面输入root密码后回车 # vi /etc/fstab 在编辑该文件的时候，系统提示该文件为只读，无法编辑，原因是在进入单用户模式后，由于根分区是只读的，需要通过重新挂载 # mount -o remount,rw / # vi /etc/fstab 把无法挂载的分区那一行行首用#注释掉或将那一行直接删除掉，重新启动就OK了。 # reboot Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/unmount.html":{"url":"linux/unmount.html","title":"Linux-卸载分区","summary":"Linux-卸载分区","keywords":"","body":"Linux-卸载分区 注意，卸载分区会格式化分区内所有的数据，请谨慎操作或进行数据备份 # df -hT 准备卸载/dev/sda6这个分区 # umount /data2 重新检查一下 # df -hT # fdisk -l 发现待分区的磁盘 /dev/sda 对该磁盘进行卸载分区，输入m并回车 # fdisk /dev/sda # m 输入帮助 # p 打印分区表 卸载/dev/sda6分区 此时注意/dev/sda6是刚刚卸载了/data2的分区名 # d 删除一个分区 # 6 删除第六个分区 重新打印分区表发现已卸载/dev/sda6分区 # p # w 将表写入磁盘并退出 再检查一遍 # fdisk /dev/sda # p 打印分区表 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/new_ext_par.html":{"url":"linux/new_ext_par.html","title":"Linux-新建扩展分区","summary":"Linux-新建扩展分区","keywords":"","body":"Linux-新建扩展分区 # fdisk -l 要进行新建扩展分区的磁盘是 /dev/sda # fdisk /dev/sda # p 打印分区表 此时磁盘已经有了3个分区，如果要再弄2个分区就不行，这个时候我们进行新建扩展分区 # n 添加一个新的分区 # e 添加一个扩展分区 # p 打印分区表 此时已经看见扩展分区创建完成，在扩展分区下面新建2个分区 因为现在扩展分区是20G 所以下面的2个分区都给10G # n # +10G # p 重复上面的操作 # n # 回车 # 回车 此时回车等于把磁盘剩下的所有空间给了此分区 # p 创建完毕 保存并重启 # w # reboot 重新登入系统 # fdisk -l 需要格式化 /dev/sda5 /dev/sda6 分区 --- ext4是磁盘文件系统的格式，也可以是ext3 # mkfs -t ext4 /dev/sda5 # mkfs -t ext4 /dev/sda6 # mount /dev/sda5 /data 报错:mount: mount point /data does not exist 原因是根目录没有此文件夹 创建文件夹 # mkdir /data # mkdir /data2 # mount /dev/sda5 /data 把分区 /dev/sda5 挂载到 /data 目录下 # mount /dev/sda6 /data2 把分区 /dev/sda6 挂载到 /data2 目录下 # df -hT 查看是否挂载成功 分区格式类型是ext4 分区大小也是10G 此时注意，这样机器重启后就重置了，如果需要永久生效需要设置开机自动挂载（磁盘） 开机自动挂载（磁盘） # vi /etc/fstab --- 最后面添加 /dev/sda5 /data ext4 defaults 0 0 /dev/sda6 /data2 ext4 defaults 0 0 Tips: 第一列：分区的UUID或分区名 例如:/dev/sda5 第二列：Mount point：设备的挂载点，就是你要挂载到哪个目录下。 第三列：filesystem：磁盘文件系统的格式，包括ext2、ext3、reiserfs、nfs、vfat等 第四列：parameters：文件系统的参数 Async/sync 设置是否为同步方式运行，默认为async auto/noauto 当下载mount -a 的命令时，此文件系统是否被主动挂载。默认为auto rw/ro 是否以以只读或者读写模式挂载 exec/noexec 限制此文件系统内是否能够进行\"执行\"的操作 user/nouser 是否允许用户使用mount命令挂载 suid/nosuid 是否允许SUID的存在 Usrquota 启动文件系统支持磁盘配额模式 Grpquota 启动文件系统对群组磁盘配额模式的支持 Defaults 同事具有rw,suid,dev,exec,auto,nouser,async等默认参数的设置 第五列：能否被dump备份命令作用：dump是一个用来作为备份的命令。通常这个参数的值为0或者1 0 代表不要做dump备份 1 代表要每天进行dump的操作 2 代表不定日期的进行dump操作 第六列：是否检验扇区：开机的过程中，系统默认会以fsck检验我们系统是否为完整（clean）。 0 不要检验 1 最早检验（一般根目录会选择） 2 1级别检验完成之后进行检验 Tips: 查看各个分区的UUID和磁盘文件系统的格式 # blkid Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/parted.html":{"url":"linux/parted.html","title":"Centos用parted分区超过2TB硬盘-分区格式化","summary":"Centos用parted分区超过2TB硬盘-分区格式化","keywords":"","body":"Centos用parted分区超过2TB硬盘-分区格式化 1、问题描述 1、问题一 CentOS 6.x 在格式化大于16TB的ext4分区时，会提示如下错误： mke2fs 1.41.12 (17-May-2010) mkfs.ext4: Size of device /dev/sda1 too big to be expressed in 32 bits using a blocksize of 4096. 2、问题二 CentOS 6.x 无法使用fdisk分区大于2TB的磁盘。 2、原因分析 1、问题一： 原因在于CentOS 自带的 e2fsprogs 版本为1.41.12较低，无法创建16TB以上的文件系统。 2、问题二： 原因在于MBR分区表只支持2T磁盘。 3、解决方案 1、问题一： 解决方案为手工下载最新的e2fsprogs源码包，进行编译安装，然后使用mkfs.ext4命令使用64位的方式进行磁盘格式化。 2、问题二： 使用parted命令将MBR分区表，改为GPT分区表。 通过输入print 设备名进入分区命令行模式如下图 通过parint打印列出当前分区设备的磁盘容量大小，如下图12.9tb 设置磁盘分区为gpt模式，mklabel gpt然后点击YEs继续(提示磁盘的数据可能会丢失是否继续） 提示下面警告，再mkpart primary 0 12.9TB，下一条警告忽略继续即可输入 i 或者 ignore（primary为分区的名字，如图中所示） 退出parted，设置好之后输入quit退出（本经验以最简单的一个盘分一个区为例） 分区格式化 把创建好的大分区进行格式化，通过fdisk -l再次查看确认 直接用mkfs.ext4 /dev/sdb1格式化会报错，在文章开头已经介绍了，这里我们先下载最新的e2fsprogs源码包，下载地址如下： ftp://ftp.ntu.edu.tw/linux/kernel/people/tytso/e2fsprogs/ 下载的版本为1.43.8，进行编码安装： tar -zxvf e2fsprogs-1.43.8.tar.gz cd e2fsprogs-1.43.8 mkdir build cd build/ ../configure (如果linux系统是最小化安装，会缺少gcc相关依赖包../configure之前要先安装gcc，命令yum install gcc，否则configure失败下一步make操作无法进行) make make install 编译完成后使用如下命令格式化： mke2fs -O 64bit,\\ has_journal,extents,\\ huge_file,flex_bg,uninit_bg,\\ dir_nlink,\\ extra_isize \\ -i 4194304 \\ /dev/sbd1 或者： mkfs.ext4 -O 64bit /dev/sdb1（建议用这个） Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/fdisk.html":{"url":"linux/fdisk.html","title":"fdisk分区不超过2T的磁盘","summary":"fdisk分区不超过2T的磁盘","keywords":"","body":"fdisk分区不超过2T的磁盘 不超过2T的磁盘都可以使用fdisk命令进行分区，如果超过2T，用fdisk每次最多也只能分2T的空间 1、首先用fdisk -l发现待分区的磁盘 /dev/sdb # fdisk -l 2、fdisk /dev/sdb对该磁盘进行分区，输入m并回车 # fdisk /dev/sdb 3、输入n并回车，n是“new”新建分区的意思 4、输入p并回车 5、输入数字1并回车 6、采用默认值一直回车会将整个20G都分给/dev/sdb1 7、输入w \"write\"并回车，意思是对刚才的结果进行保存 8、再次使用fdisk -l查看分区的结果 如图分的新区为/dev/sdb1,，创建的新区格式化后就可以挂载使用了 # reboot --- 重启一下，防止报错: Could not stat /dev/sdsa4 --- No such file or directory # mkfs -t ext3 /dev/sdb1 # mount /dev/sdb1 /data # df -hT Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/bond_network.html":{"url":"linux/bond_network.html","title":"Linux中bond网卡绑定方法","summary":"Linux中bond网卡绑定方法","keywords":"","body":"Linux中bond网卡绑定方法 首先在虚拟机上添加俩块虚拟网卡（具体做法不在赘述） 然后为网卡添加配置文件。文件内容如下： # vi /etc/sysconfig/network-scripts/ifcfg-eth0 # vi /etc/sysconfig/network-scripts/ifcfg-eth1 HWADDR对应mac地址 ifconfig -a 可以查看 UUID对应网卡UUID ➡️ Linux 查看网卡UUID 两块网卡的配置文件差不多，就是mac地址和设备名称还有UUID需要更改。 接下来就是要添加bond网卡的配置文件 # vi /etc/sysconfig/network-scripts/ifcfg-bond0 Tips:BONDING_OPTS=\"miimo=10 mode=1\" 网卡配置模式以及通讯时间（单位为毫秒） 在linux中实现多网卡的绑定 介绍常见的7种Bond模式 最后重启网络服务。（在7.0以上的版本有NetworkManager，需要关闭此项服务，bond网卡才能生效） Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"linux/uuid.html":{"url":"linux/uuid.html","title":"Linux-查看网卡UUID","summary":"Linux-查看网卡UUID","keywords":"","body":"Linux-查看网卡UUID Linux 查看网卡UUID 1、首先我们查看一下nmcli是哪个软件包提供的 # yum provides \"*/nmcli\" 2、安装NetworkManager服务 # yum -y install NetworkManager 3、启动NetworkManager服务 # service NetworkManager start 4、查看网卡UUID # nmcli con Tips:如果有发现有报错 -- 查看/var/log/messages日志 # vi /var/log/messages tips:按两下大写的G跳到最后一页 报错： ... Apr 20 14:53:05 localhost NetworkManager[2013]: NetworkManager (version 0.8.1-113.el6) is starting... Apr 20 14:53:05 localhost NetworkManager[2013]: Read config file /etc/NetworkManager/NetworkManager.conf Apr 20 14:53:05 localhost NetworkManager[2013]: [1492671185.606620] [nm-dbus-manager.c:278] nm_dbus_manager_init_bus(): Could not get the system bus. Make sure the message bus daemon is running! Message: Failed to connect to socket /var/run/dbus/system_bus_socket: Connection refused ... -- 需要先启动messagebus，再启动NetworkManager # /etc/init.d/messagebus start # service NetworkManager start 5、运行nmcli # nmcli con 报错: # vi /var/log/messages 发现有报错 g_slist_free_full 属于glist 的一个方法，缺少glist 解决方法: # yum -y install glib2-devel 6、此时再运行nmcli即可查看网卡UUID # service NetworkManager start # nmcli con Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:34 "},"elk/linux_es5.html":{"url":"elk/linux_es5.html","title":"Linux-搭建-ElasticSearch5.x","summary":"Linux-搭建-ElasticSearch5-x","keywords":"","body":"Linux-搭建-ElasticSearch5-x 一、ElasticSearch5.2.2 安装 1、检查 JDK版本（必须使用jdk1.8版本） # java -version 2、初始化环境 # service iptables status # service iptables stop # chkconfig iptables off # yum install -y wget vim # vim /etc/selinux/config //SELINUX=enforcing更改为SELINUX=disabled # reboot 3、下载安装ElasticSearch5.2.2 # cd /usr/local/ # wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.5.2.tar.gz # tar -zxvf elasticsearch-5.5.2.tar.gz # cd elasticsearch-5.5.2/ # vim config/elasticsearch.yml //添加如下配置 # 配置es的集群名称, es会自动发现在同一网段下的es,如果在同一网段下有多个集群,就可以用这个属性来区分不同的集群 cluster.name: elasticsearch # 节点名称 node.name: \"es_client\" bootstrap.memory_lock: false bootstrap.system_call_filter: false network.host: 0.0.0.0 4、因为安全问题 elasticsearch 不让用root用户直接运行，所以要创建新用户并运行 # groupadd elsearch # useradd elsearch -g elsearch -p elasticsearch # chown -R elsearch:elsearch /usr/local/elasticsearch-5.5.2 //更改用户权限 # su elsearch # ./bin/elasticsearch Tips：启动发现报错 切换成root用户执行以下命令 # su root # vim /etc/security/limits.conf //添加如下内容: * soft nofile 65536 * hard nofile 131072 * soft nproc 2048 * hard nproc 4096 # vim /etc/security/limits.d/90-nproc.conf //修改如下内容： * soft nproc 1024 #修改为 * soft nproc 2048 # vim /etc/sysctl.conf 添加下面配置： vm.max_map_count=655360 并执行命令： # sysctl -p 重新启动ElasticSearch # su elsearch # ./bin/elasticsearch # ./bin/elasticsearch -d //后台运行 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:33 "},"elk/es_cluster.html":{"url":"elk/es_cluster.html","title":"搭建ElasticSearch-6.1.3分布式集群","keywords":"","body":"搭建ElasticSearch-6.1.3分布式集群 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-27 09:26:28 "},"elk/es_head.html":{"url":"elk/es_head.html","title":"Elasticsearch-5.5.0安装head插件","summary":"Elasticsearch-5-5-0安装head插件","keywords":"","body":"Elasticsearch-5-5-0安装head插件 Tips:环境 楼主博客：https://zhousiwei.gitee.io/ Windows7,JDK-1.8,ElasticSearch-5.5.0,node-v8.1.2,git windows用户建议安装个 TortoiseGit客户端 下载Elasticsearch 5.5.0 ➡️ https://www.elastic.co/downloads/elasticsearch zip和tar格式是各种系统都通用的，解压之后启动Elasticsearch即可。 1、npm安装grunt $ npm install -g grunt-cli $ grunt -version 注意这里安装的时候路径一定要切换到grunt-cli文件夹下面 这些是Grunt file.js中引用的，分别下载 $ npm install grunt-contrib-copy $ npm install grunt-contrib-concat $ npm install grunt-contrib-uglify $ npm install grunt-css 2、下载官方源码 官方源码 ➡️ https://github.com/mobz/elasticsearch-head $ git clone git://github.com/mobz/elasticsearch-head.git 3、修改head源码 由于head的代码还是2.6版本的，直接执行有很多限制，比如无法跨机器访问。因此需要用户修改两个地方： 目录：head/Gruntfile.js： 增加hostname属性，设置为* connect: { server: { options: { port: 9100, hostname: '*', base: '.', keepalive: true } } 3.1、修改连接地址： 目录：head/_site/app.js 修改head的连接地址: this.base_uri = this.config.base_uri || this.prefs.get(\"app-base_uri\") || \"http://localhost:9200\"; 把localhost修改成你es的服务器地址，如： this.base_uri = this.config.base_uri || this.prefs.get(\"app-base_uri\") || \"http://10.10.10.10:9200\"; 4、运行Elasticsearch-head 修改elasticsearch的参数 修改一下es使用的参数。编辑config/elasticsearch.yml 注意，设置参数的时候:后面要有空格！ # 换个集群的名字，免得跟别人的集群混在一起 cluster.name: es-5.0-test # 换个节点名字 node.name: node-101 # 修改一下ES的监听地址，这样别的机器也可以访问 network.host: 0.0.0.0 # 默认的就好 http.port: 9200 # 增加新的参数，这样head插件可以访问es http.cors.enabled: true http.cors.allow-origin: \"*\" 开启ES-5.5.0：ElasticSearch-5.0.0\\bin\\elasticsearch.bat 然后在head源码目录中，执行npm install进行安装： $ npm install 初次运行安装可能会报警告或错误。可以重新运行一次npm install 最后，使用grunt命令在head源码目录下启动： $ grunt server 效果如图： 访问 http://localhost:9100 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:33 "},"elk/es_bigdesk.html":{"url":"elk/es_bigdesk.html","title":"ElasticSearch-2-x-x版本安装bigdesk插件","summary":"ElasticSearch-2-x-x版本安装bigdesk插件","keywords":"","body":"ES插件BigDesk安装 bigdesk Github地址：https://github.com/lukas-vlcek/bigdesk bigdesk支持的最新版本的ES是1.3.0 ... 1.3.x 然而想要在新版本ES上安装（2.x.x），项目中遇到过一些BUG，在ES在最新版本中有修复，所以采用了2.3.0的版本 head插件查看数据和集群其他一些挺方便，但是对集群状况监控不够细致，而且使用中有一些BUG问题，一般会和bigdesk、kopf结合使用。 下载安装的时候出现问题： Installing lukas-vlcek/bigdesk... Trying https://github.com/lukas-vlcek/bigdesk/archive/master.zip ... Downloading.......................................................................................................................................................................................................................DONE Verifying https://github.com/lukas-vlcek/bigdesk/archive/master.zip checksums if available ... NOTE: Unable to verify checksum for downloaded plugin (unable to find .sha1 or .md5 file to verify) ERROR: Could not find plugin descriptor ‘plugin-descriptor.properties‘ in plugin zip 解决办法： 1. 下载bigdesk的master的zip包 2. 解压到安装路径下 elasticsearch-2.3.0/plugins/目录下，会有一个bigdesk或者bigdesk-master（可以改成bigdesk）目录 3. 提示没有找到plugin-descriptor.properties文件，那就创建这个文件，并写入以下内容 description=bigdesk version=bigdesk name=bigdesk site=true 保存OK，大功告成。 此时目录树为 plugins/bigdesk/_site/* plugin-descriptor.properties文件放置在plugins/bigdesk/下 解压的文件放在/_site/目录下 然后在本地浏览器中输入 http://localhost:9200/_plugin/bigdesk/ 注：_plugin后面的bigdesk就是plugins下目录名字，若是bigdesk-master，则需要写这个名字 本以为会正常运行，然而出现了一个js弹框，有这样的内容 Bigdesk may not work correctly! Found ES node version:2.3.0 Require ES node version:>= 1.0.0.RC1 解决办法： 定位到plugins/bigdesk/_site/js/store目录，打开BigdeskStore.js，定位到142行 return (major == 1 && minor >= 0 && maintenance >= 0 && (build != ‘Beta1‘ || build != ‘Beta2‘)); 看到这么一行，把 major ==1 改成 major >=1，然后保存。 浏览器重新打开 http://localhost:9200/_plugin/bigdesk/ OK.可以看到正常运行了。 分享一下楼主打包的文件 。插件包含了head插件和bigdesk插件 head插件是单独运行的 http://download.csdn.net/download/qq_30930805/10233395 其中head插件基于nodejs运行，具体参考 http://blog.csdn.net/qq_30930805/article/details/74990324 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:33 "},"elk/logstash_tomcat_log.html":{"url":"elk/logstash_tomcat_log.html","title":"logstash收集tomcat_log","summary":"logstash-收集tomcat-log","keywords":"","body":"logstash-收集tomcat-log input { file { path => \"/usr/Elastic/test_tomcat_logs/localhost_access_log*.txt\" start_position => \"beginning\" #从文件开始处读取 type => \"tomcat_access_log\" #sincedb_path => \"/dev/null\" } } filter { if [type] == \"tomcat_access_log\" { grok { match => { \"message\" => \"%{COMMONAPACHELOG}\" } } kv { source => \"request\" field_split => \"&?\" value_split => \"=\" } urldecode { all_fields => true } } #定义时间戳的格式 date { match => [ \"timestamp\", \"yyyy-MM-dd-HH:mm:ss\" ] locale => \"cn\" } } output { if [type] == \"tomcat_access_log\" { elasticsearch { action => \"index\" #es要执行的动作 hosts => [\"192.168.1.114:9201\",\"192.168.1.114:9202\"] #事件要被写进的索引，可是动态的用%{foo}语句 index => \"logstash-tomcat_access_logs-%{+YYYY.MM.dd}\" #protocol => \"http\" #这个打开会报错 #index => \"system-message-%{+YYYY.MM.dd}\" #一个默认的es mapping 模板将启用（除非设置为false 用自己的template） #manage_template => true #有效的filepath 设置自己的template文件路径，不设置就用已有的 #template => \"/data1/cloud/logstash-5.5.1/filebeat-template.json\" #template_name => \"my_index\" #在es内部模板的名字 #template_overwrite => true #document_type => \"log\" user => \"\" password => \"\" } } stdout { codec => rubydebug } } Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:33 "},"elk/kibana_map.html":{"url":"elk/kibana_map.html","title":"Kibana使用高德地图","summary":"Kibana使用高德地图","keywords":"","body":"Kibana使用高德地图 说明 目前Kibana默认自带的地图全部是英文，更换高德地图对地图汉化 一、修改配置 1、 编辑kibana配置文件kibana.yml，最后面添加 tilemap.url: 'http://webrd02.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=7&x={x}&y={y}&z={z}' 删除kibana目录下的optimize/bundles文件夹后，重启，如果bundles目录没有新文件生成，注意权限哈！ 2、 在logstash服务器下载IP地址归类查询库 # wget http://geolite.maxmind.com/download/geoip/database/GeoLite2-City.mmdb.gz # gunzip GeoLite2-City.mmdb.gz 3、编辑logstash配置文件 input { stdin {} } filter { geoip { source => \"message\" target => \"geoip\" database => \"/usr/local/logstash-5.1.1/config/GeoLite2-City.mmdb\" add_field => [\"[geoip][coordinates]\",\"%{[geoip][longitude]}\"] add_field => [\"[geoip][coordinates]\",\"%{[geoip][latitude]}\"] } } output { elasticsearch { hosts => \"172.16.11.199\" index => \"logstash-map-%{+YYYY.MM.dd}\" } } 配置解释 这里为了测试，数据通过终端手动输入 geoip: IP查询插件 source: 需要通过geoip插件处理的field，一般为ip，这里因为通过控制台手动输入的是ip所以直接填message，生成环境中如果查询nginx访问用户，需先将客户端ip过滤出来，然后这里填clientip即可 target: 解析后的Geoip地址数据，应该存放在哪一个字段中，默认是geoip这个字段 database: 指定下载的数据库文件 add_field: 这里两行是添加经纬度，地图中地区显示是根据经纬度来识别 效果图 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:33 "},"elk/grok_debugger.html":{"url":"elk/grok_debugger.html","title":"ELK之本地Grok-Debugger配置","summary":"ELK之本地Grok-Debugger配置","keywords":"","body":"ELK之本地Grok-Debugger配置 1、Ruby环境安装 1.1、清理已安装过的 # yum erase ruby ruby-libs ruby-mode ruby-rdoc ruby-irb ruby-ri ruby-docs # yum remove ruby 1.2、Ruby的安装(别使用ruby最新的2.2或者2.3的版本，可能出现部分组件无法安装) # yum install -y wget unzip # cd /usr/local # yum -y install openssl-devel gcc # wget https://ruby.taobao.org/mirrors/ruby/2.1/ruby-2.1.7.tar.gz # tar zxf ruby-2.1.7.tar.gz # cd ruby-2.1.7 # ./configure --prefix=/usr/local/ruby2.1.7 # make && make install # echo 'export PATH=/usr/local/ruby2.1.7/bin:$PATH'>>/etc/profile # source /etc/profile 1.3、RubyGems工具安装 # cd /usr/local # wget http://rubygems.global.ssl.fastly.net/rubygems/rubygems-2.6.2.tgz # tar zxf rubygems-2.6.2.tgz # cd rubygems-2.6.2 # ruby setup.rb 1.4、替换gem源,由于网络环境的问题，访问官方源非常慢，使用淘宝的gem源 # gem sources --add https://ruby.taobao.org/ --remove https://rubygems.org/ # gem sources –l 2、GrokDebug的安装 2.1、下载源码包 # mkdir /usr/local/grokbug # cd /usr/local/grokbug # wget https://codeload.github.com/nickethier/grokdebug/zip/master # unzip master # mv grokdebug-master/* . # rm -rf grokdebug-master/ 2.2、Ruby组件安装(以下组件都对版本有相应的要求) --- 查看缺少的组件 # ruby config.ru --- 就会提示组件及对应的版本 # gem install bundler gem install cabin -v=0.5.0 gem install haml -v=3.1.7 gem install jls-grok -v=0.10.10 gem install json -v=1.7.5 gem install kgio -v=2.8.0 gem install rack -v=1.4.1 gem install rack-protection -v=1.2.0 gem install raindrops -v=0.11.0 gem install shotgun -v=0.9 gem install tilt -v=1.3.3 gem install sinatra -v=1.3.3 gem install unicorn -v=4.6.3 2.3、启动服务 # cd /usr/local/grokbug # nohup bundle exec unicorn -p 8080 -c ./unicorn & 2.4、关闭防火墙 # service iptables stop # chkconfig iptables off 2.5、替换Google的jquery源 # cd /usr/local/grokbug # cd views 执行下面5条语句 # sed -i 's#//ajax.googleapis.com/ajax/libs/jquery/1.8.1/jquery.min.js#//lib.sinaapp.com/js/jquery/1.8.1/jquery.min.js#g' index.haml # sed -i 's#//ajax.googleapis.com/ajax/libs/jqueryui/1.9.2/jquery-ui.min.js#//lib.sinaapp.com/js/jquery-ui/1.9.2/jquery-ui.min.js#g' index.haml # sed -i 's#//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js#//lib.sinaapp.com/js/jquery/1.7.2/jquery.min.js#g' patterns.haml # sed -i 's#//ajax.googleapis.com/ajax/libs/jqueryui/1.9.0/themes/ui-lightness/jquery-ui.css#//lib.sinaapp.com/js/jquery-ui/1.9.0/themes/ui-lightness/jquery-ui.css#g' layout.haml # sed -i 's#//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js#//lib.sinaapp.com/js/jquery/1.7.2/jquery.min.js#g' discover.haml 测试，通过web路径访问测试了 http://xxx:8080 Copyright © 试剑江湖 2020 all right reserved，powered by Gitbook修订时间： 2023-02-26 13:36:33 "}}